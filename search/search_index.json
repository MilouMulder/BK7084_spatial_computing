{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spatial Computing Project - Zoho\u2019s Pearl Our project is named Zoho\u2019s Pearl . In this analogy Rotterdam can be seen as the clamshell. Worn and rough on the outside due to its history and pronounced character, but beautiful on the inside, strengthened by its ever changing character and ability to stimulate growth. A strong shield that contains the foundations for beautiful flourishing development. In our case these foundations are found in the neighbourhood of Zoho. Where it was once a run down business area, we now see the first steps of renewal. During our design process we took the foundations offered to create a pearl worthy of Zoho. A building that will not only consist of living and working, but will be a social hub for the entire neighbourhood. We seek to stimulate inhabitants to network and grow in their environment. Similar to how the pearl will transform Zoho, we believe it will encourage inhabitants to flourish on an individual level. This web portal is the result of the course BK7083 \"Computational Design Studio\" given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. During this minor, we have formulated a programme of requirements and subsequently used mathematical spatial computing constructs to design and simulate the optimum building. The assignment of this course consists of a computational design for the site in the area of the Rotterdamse Maakkwartier. Currently, this building (also known as ZOHO) is used for residency, workshops, studios and startups. This is why the ZOHO is promoted with the following: For and by makers in design, art, culture, media, tech, food, architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves, ZOHO, and the city in an innovative way. (Stichting ZOHOCITIZENS Ondernemerscollectief, 2018) The aim of this project is to design a new building that fits into the requirements given by the tutors, the (imaginary) future residents and ourselves, using diverse python scripts. The structure of this webpage is based on the assignments of the weeks, where each week has its own folder. These folders are divided into two extra folders: \u2018Process\u2019 and \u2018Products\u2019. In the folders \u2018Process\u2019 the research, which was needed for the final products and conclusions, is documented. The conclusions can therefore be found in the folder \u2018Products\u2019.","title":"Home"},{"location":"#spatial-computing-project-zohos-pearl","text":"Our project is named Zoho\u2019s Pearl . In this analogy Rotterdam can be seen as the clamshell. Worn and rough on the outside due to its history and pronounced character, but beautiful on the inside, strengthened by its ever changing character and ability to stimulate growth. A strong shield that contains the foundations for beautiful flourishing development. In our case these foundations are found in the neighbourhood of Zoho. Where it was once a run down business area, we now see the first steps of renewal. During our design process we took the foundations offered to create a pearl worthy of Zoho. A building that will not only consist of living and working, but will be a social hub for the entire neighbourhood. We seek to stimulate inhabitants to network and grow in their environment. Similar to how the pearl will transform Zoho, we believe it will encourage inhabitants to flourish on an individual level. This web portal is the result of the course BK7083 \"Computational Design Studio\" given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. During this minor, we have formulated a programme of requirements and subsequently used mathematical spatial computing constructs to design and simulate the optimum building. The assignment of this course consists of a computational design for the site in the area of the Rotterdamse Maakkwartier. Currently, this building (also known as ZOHO) is used for residency, workshops, studios and startups. This is why the ZOHO is promoted with the following: For and by makers in design, art, culture, media, tech, food, architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves, ZOHO, and the city in an innovative way. (Stichting ZOHOCITIZENS Ondernemerscollectief, 2018) The aim of this project is to design a new building that fits into the requirements given by the tutors, the (imaginary) future residents and ourselves, using diverse python scripts. The structure of this webpage is based on the assignments of the weeks, where each week has its own folder. These folders are divided into two extra folders: \u2018Process\u2019 and \u2018Products\u2019. In the folders \u2018Process\u2019 the research, which was needed for the final products and conclusions, is documented. The conclusions can therefore be found in the folder \u2018Products\u2019.","title":"Spatial Computing Project - Zoho\u2019s Pearl"},{"location":"a1.1_Process/","text":"Design philosophy To substantiate our design decisions, we formulated our own Design Philosophy containing the design goals, key performances and a vision about the future residents. Furthermore, this design philosophy includes the vision of how the building will fit in and what it will add to its environment. Design goals The given Design goals are separated into two categories: quantitative and qualitative (see Figure X ). Figure X: Given design goals Additional we formulated four more design goals which have priority: Optimise the building for Sunlight and Sound Pollution With the possibilities that come along with the different python scripts, our aim is it to design a building that is optimised on the aspects of sunlight and sound pollution. This is not only important for the functions that will be found in the future building, but also for its environment. Based on the calculations, we e.g. will shape an envelope that blocks the sun for the surrounded buildings minimally. Develop a layout that suits the residents Every target group has its own needs. These needs can not only be translated into the desirable view or avoiding noise disturbance, but it can also be translated into the design of the floor plans and the connections between different spaces. The elderly, for example, are in a different phase of their life than students. Students probably will need a bigger bedroom so they will have enough space to study. Therefore, elderly people will only sleep in their bedroom but will spend more time in their living room, so in this case, a bigger living room is preferred. With these kinds of guidelines, we will create a suitable residence for our residents. Create a pleasant Living Environment We want to see our future residents happy. Happy residents will become happy and friendly neighbours which will lead to a pleasant living environment, an environment that feels like home , and not only a homey residence. We want to provoke this by creating spaces where the residents can interact with each other (like a co-cooking center or a community center). Furthermore, a healthy amount of daylight and greenery will increase the living quality. Add possibilities to the Rotterdamse Maakkwartier The current building contains not only residences, it is also filled with diverse workshop-rooms, studios and small startups. This great and strong principle is very important to the neighbourhood and therefore should be preserved in the new building. Additionally to this, diverse public functions will be added creating a building that will be a cooperative live-work-playassociation, accessible for residents and other citizens. Figure X: Additional design goals Future residents The shortage of residency in today\u2019s society is an important issue that affects a variety of citizens and therefore it has to be addressed. Due to the significance of this problem, the project will offer housing where people of different life stages can live together. Starters, students and people with the need for assisted living will form a residential community which can lead to beautiful interactions. Especially during the current pandemic, we see how much we depend on each other: for example, it is not safe for the elderly to do groceries, so it would be great if neighbours (in our case starters of students) could do some groceries for them. Additionally, the connection between the target groups will be supported by different design decisions, such as the possibilities to cook together or for each other in the co-cooking center, do workshops together or meet each other in the community center. As already mentioned in the design goals , we want to develop a layout that suits the residents. So for the starters we will realize a wonted apartment including a bathroom, living room (kitchen, dinner room and sitting room in one), a bedroom and an additional room. This additional room can be used for different functions like a washing room, a study room or an extra bedroom for their first child. Since starters are at the beginning of their life (just graduated, getting a job and maybe starting their own family), it is important that there is enough space for the residence to grow in. For the people in the need of assisted living it is important that they will be able to stay as long as possible in their own houses, before they have to move to a retirement home. To make this happen there will be additional modifications like a wider corridor and kitchen and special devices in the bathroom to make the apartment walker and wheelchair friendly. There will be two kind of floor plans for the students : a bigger one habitable for four students and a smaller one, a studio. By creating different floor plans, we want to attract different target groups within the \u2018student-world\u2019, namely those who want to live in a 'bigger' house with other people, and those who would like to live on their own. Figure X: Future residents Analysis on the Site Before we begin the computational design of the new building, it is important to investigate the current state of our site and its environment. Therefore we did research on different aspects that we thought were important to take into account for the new building. This research started with analysing the building plot: as you can see in Figure X the site is devided in a compulsory part and a optional part. To keep the streets intact, we decided to stay within the borders of the comulsory building plot. Figure X: Given building plot Building visualisation The visualization of the surrounding environment of our site ( Figure X ) consists of a scale of architectural styles. This is due to the different building years, which have led to a diverse neighbourhood where different facades are positioned next to each other. The functions of the buildings also play a role in the diverse visualization. The main function is dwelling but there are also businesses and offices situated. Furthermore, our site is in ZOHO, which is the name of the area of the Rotterdamse Maakkwartier. A developing working and living space for and by makers in design, art, culture, media, tech, food architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves and ZOHO. This is reflected in the appearance of the environment. Creative and notable graphs can be found on the walls, which gives the area a coming up and hip neighbourhood feel. Moreover, near the site there is a shared garden and sportsfield for residents to use and where they can meet others. After analyzing the environment it is clear that the current building ( Figure X ) blends right in the area. Different kinds of functions that cause multiple identities. The building is a combination of a variation of heights and both monotone and trendy patterned facades. Figure X: Surrounding environment Figure X: Building visualisation Access routes In Figure X the accessibility of our site is shown. Our site is directly surrounded by a sidewalk with a few thresholds for access to the parking garage. Only the northeast side of the building is more focused on the accessibility for cars, because of the direct street that is situated opposite the building. Near the building, there are some car parking and a few bicycle parking. Furthermore, the main roads for vehicles that surround our site are bicycle roads (a bicycle road where cars are the guests and cyclists have the priority) and \u2018normal\u2019 car roads. Figure X visualizes which car roads are busy and which are widely used. In addition to this, the green walking route that is close to our site is shown. Figure X: Access routes to the site Building heights in the environment If you look at the built environment, as shown in Figure X , and start in the north/ northeast, you can see that these buildings are mainly between 18 and 23 meters high. Most of these buildings are terraced houses. If you go around the map clockwise, the buildings are getting higher. Here we still have residents' buildings, but now shaped as duplex houses. At the bottom of the map (south), we are getting closer to the center of Rotterdam. This is why the buildings in the Southwest are higher than the buildings in the north: These are mainly office buildings with a height between 40 meters or even higher than 100 meters. To finish the clock, in the West, same as in the Southeast, we can find duplex houses. Nevertheless, these buildings have more storeys. With a height of 22 meters, our site currently fits in the street scene very well due to the similar building heights. But if the future building is higher than 40 meters, it will become more of a landmark. Figure X: Building heights in the environment Programme of requirements Additionally to the Design Philosophy , we formulated a Programme of requirements. This does not only include spatial requirements like the square meter or the ideal storey but also the functional requirements like the number of bathrooms or storage space that is needed. Furthermore it also contains important information about the noise . Functions size In Figure X , a table is shown where aspects concerning the sizes of all the spaces can be found: The floor height, on which storey, square meter, amount of rooms, amount of voxels and for how many people the space is designed. This information will be used to construct the building in spatial computing. Figure X: Sizes of the functions Functional requirements In Functions size we already mentioned the number of square meters and voxels which are needed for each function. Though, it is necessary to subdivide these functions in separate rooms so the voxels can grow in rooms instead of categorised in functions. The table underneath ( Figure X ) shows exactly how many square meters will be needed for e.g. the technical room of the arcade, or how big the staff room in the supermarket will be. More information, regarding the amount of voxels fitting into these spaces, can be found here . Figure X: Sizes of the functions In addition to this, Figure X gives an overview of the percentage distribution of the different functions. The inside of the ring represents the total amount of space which is required for the overarching functions: Meeting space , housing , private facilities , public facilities and parking . The outside ring shows the specific facilities belonging to each overarching function. Figure X: Distribution of facilities throughout the entry building By assigning the subdivided facilities to different storey\u2019s, as shown in Figure X , we created our first possibility for locating each room. By mapping the facilities in a 3 dimensional way, we were able to see the grouping of the different kinds of spaces and thereby we could also see if our first attempt is possible. For example, all public facilities are located on the ground floor causing the possibility to make a seperate entrance for the residents of the building and their private facilities. You can also see that the assisted livings are located on the same floor as the private facilities in the hope that these people will use the facilities easier. This is just the first attempt for a better overview, but further possibilities are not excluded and the mapping probably will change during the following design process. Figure X: Distribution of facilities per storey Noise table The average assigned noise level per space can be seen in Figure X . As well as the hours in which the noise levels occur. The corresponding reason for the chosen time in which the noise levels score a middle to high level has also been added. Besides, the spaces that are noise sensitive have also been classified. Figure X: Noise table Noise chart The previous table showed us the average noise level and sensitivity of the various rooms. To have a better impression when the functions reach the different noise levels in specific moments of the day, the following noise-diagram is made. This gives us a good overview of which functions can be located next to each other, and which ones have to be separated by a greater distance. Figure X: Noise chart","title":"Process"},{"location":"a1.1_Process/#design-philosophy","text":"To substantiate our design decisions, we formulated our own Design Philosophy containing the design goals, key performances and a vision about the future residents. Furthermore, this design philosophy includes the vision of how the building will fit in and what it will add to its environment.","title":"Design philosophy"},{"location":"a1.1_Process/#design-goals","text":"The given Design goals are separated into two categories: quantitative and qualitative (see Figure X ). Figure X: Given design goals Additional we formulated four more design goals which have priority: Optimise the building for Sunlight and Sound Pollution With the possibilities that come along with the different python scripts, our aim is it to design a building that is optimised on the aspects of sunlight and sound pollution. This is not only important for the functions that will be found in the future building, but also for its environment. Based on the calculations, we e.g. will shape an envelope that blocks the sun for the surrounded buildings minimally. Develop a layout that suits the residents Every target group has its own needs. These needs can not only be translated into the desirable view or avoiding noise disturbance, but it can also be translated into the design of the floor plans and the connections between different spaces. The elderly, for example, are in a different phase of their life than students. Students probably will need a bigger bedroom so they will have enough space to study. Therefore, elderly people will only sleep in their bedroom but will spend more time in their living room, so in this case, a bigger living room is preferred. With these kinds of guidelines, we will create a suitable residence for our residents. Create a pleasant Living Environment We want to see our future residents happy. Happy residents will become happy and friendly neighbours which will lead to a pleasant living environment, an environment that feels like home , and not only a homey residence. We want to provoke this by creating spaces where the residents can interact with each other (like a co-cooking center or a community center). Furthermore, a healthy amount of daylight and greenery will increase the living quality. Add possibilities to the Rotterdamse Maakkwartier The current building contains not only residences, it is also filled with diverse workshop-rooms, studios and small startups. This great and strong principle is very important to the neighbourhood and therefore should be preserved in the new building. Additionally to this, diverse public functions will be added creating a building that will be a cooperative live-work-playassociation, accessible for residents and other citizens. Figure X: Additional design goals","title":"Design goals"},{"location":"a1.1_Process/#future-residents","text":"The shortage of residency in today\u2019s society is an important issue that affects a variety of citizens and therefore it has to be addressed. Due to the significance of this problem, the project will offer housing where people of different life stages can live together. Starters, students and people with the need for assisted living will form a residential community which can lead to beautiful interactions. Especially during the current pandemic, we see how much we depend on each other: for example, it is not safe for the elderly to do groceries, so it would be great if neighbours (in our case starters of students) could do some groceries for them. Additionally, the connection between the target groups will be supported by different design decisions, such as the possibilities to cook together or for each other in the co-cooking center, do workshops together or meet each other in the community center. As already mentioned in the design goals , we want to develop a layout that suits the residents. So for the starters we will realize a wonted apartment including a bathroom, living room (kitchen, dinner room and sitting room in one), a bedroom and an additional room. This additional room can be used for different functions like a washing room, a study room or an extra bedroom for their first child. Since starters are at the beginning of their life (just graduated, getting a job and maybe starting their own family), it is important that there is enough space for the residence to grow in. For the people in the need of assisted living it is important that they will be able to stay as long as possible in their own houses, before they have to move to a retirement home. To make this happen there will be additional modifications like a wider corridor and kitchen and special devices in the bathroom to make the apartment walker and wheelchair friendly. There will be two kind of floor plans for the students : a bigger one habitable for four students and a smaller one, a studio. By creating different floor plans, we want to attract different target groups within the \u2018student-world\u2019, namely those who want to live in a 'bigger' house with other people, and those who would like to live on their own. Figure X: Future residents","title":"Future residents"},{"location":"a1.1_Process/#analysis-on-the-site","text":"Before we begin the computational design of the new building, it is important to investigate the current state of our site and its environment. Therefore we did research on different aspects that we thought were important to take into account for the new building. This research started with analysing the building plot: as you can see in Figure X the site is devided in a compulsory part and a optional part. To keep the streets intact, we decided to stay within the borders of the comulsory building plot. Figure X: Given building plot","title":"Analysis on the Site"},{"location":"a1.1_Process/#building-visualisation","text":"The visualization of the surrounding environment of our site ( Figure X ) consists of a scale of architectural styles. This is due to the different building years, which have led to a diverse neighbourhood where different facades are positioned next to each other. The functions of the buildings also play a role in the diverse visualization. The main function is dwelling but there are also businesses and offices situated. Furthermore, our site is in ZOHO, which is the name of the area of the Rotterdamse Maakkwartier. A developing working and living space for and by makers in design, art, culture, media, tech, food architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves and ZOHO. This is reflected in the appearance of the environment. Creative and notable graphs can be found on the walls, which gives the area a coming up and hip neighbourhood feel. Moreover, near the site there is a shared garden and sportsfield for residents to use and where they can meet others. After analyzing the environment it is clear that the current building ( Figure X ) blends right in the area. Different kinds of functions that cause multiple identities. The building is a combination of a variation of heights and both monotone and trendy patterned facades. Figure X: Surrounding environment Figure X: Building visualisation","title":"Building visualisation"},{"location":"a1.1_Process/#access-routes","text":"In Figure X the accessibility of our site is shown. Our site is directly surrounded by a sidewalk with a few thresholds for access to the parking garage. Only the northeast side of the building is more focused on the accessibility for cars, because of the direct street that is situated opposite the building. Near the building, there are some car parking and a few bicycle parking. Furthermore, the main roads for vehicles that surround our site are bicycle roads (a bicycle road where cars are the guests and cyclists have the priority) and \u2018normal\u2019 car roads. Figure X visualizes which car roads are busy and which are widely used. In addition to this, the green walking route that is close to our site is shown. Figure X: Access routes to the site","title":"Access routes"},{"location":"a1.1_Process/#building-heights-in-the-environment","text":"If you look at the built environment, as shown in Figure X , and start in the north/ northeast, you can see that these buildings are mainly between 18 and 23 meters high. Most of these buildings are terraced houses. If you go around the map clockwise, the buildings are getting higher. Here we still have residents' buildings, but now shaped as duplex houses. At the bottom of the map (south), we are getting closer to the center of Rotterdam. This is why the buildings in the Southwest are higher than the buildings in the north: These are mainly office buildings with a height between 40 meters or even higher than 100 meters. To finish the clock, in the West, same as in the Southeast, we can find duplex houses. Nevertheless, these buildings have more storeys. With a height of 22 meters, our site currently fits in the street scene very well due to the similar building heights. But if the future building is higher than 40 meters, it will become more of a landmark. Figure X: Building heights in the environment","title":"Building heights in the environment"},{"location":"a1.1_Process/#programme-of-requirements","text":"Additionally to the Design Philosophy , we formulated a Programme of requirements. This does not only include spatial requirements like the square meter or the ideal storey but also the functional requirements like the number of bathrooms or storage space that is needed. Furthermore it also contains important information about the noise .","title":"Programme of requirements"},{"location":"a1.1_Process/#functions-size","text":"In Figure X , a table is shown where aspects concerning the sizes of all the spaces can be found: The floor height, on which storey, square meter, amount of rooms, amount of voxels and for how many people the space is designed. This information will be used to construct the building in spatial computing. Figure X: Sizes of the functions","title":"Functions size"},{"location":"a1.1_Process/#functional-requirements","text":"In Functions size we already mentioned the number of square meters and voxels which are needed for each function. Though, it is necessary to subdivide these functions in separate rooms so the voxels can grow in rooms instead of categorised in functions. The table underneath ( Figure X ) shows exactly how many square meters will be needed for e.g. the technical room of the arcade, or how big the staff room in the supermarket will be. More information, regarding the amount of voxels fitting into these spaces, can be found here . Figure X: Sizes of the functions In addition to this, Figure X gives an overview of the percentage distribution of the different functions. The inside of the ring represents the total amount of space which is required for the overarching functions: Meeting space , housing , private facilities , public facilities and parking . The outside ring shows the specific facilities belonging to each overarching function. Figure X: Distribution of facilities throughout the entry building By assigning the subdivided facilities to different storey\u2019s, as shown in Figure X , we created our first possibility for locating each room. By mapping the facilities in a 3 dimensional way, we were able to see the grouping of the different kinds of spaces and thereby we could also see if our first attempt is possible. For example, all public facilities are located on the ground floor causing the possibility to make a seperate entrance for the residents of the building and their private facilities. You can also see that the assisted livings are located on the same floor as the private facilities in the hope that these people will use the facilities easier. This is just the first attempt for a better overview, but further possibilities are not excluded and the mapping probably will change during the following design process. Figure X: Distribution of facilities per storey","title":"Functional requirements"},{"location":"a1.1_Process/#noise-table","text":"The average assigned noise level per space can be seen in Figure X . As well as the hours in which the noise levels occur. The corresponding reason for the chosen time in which the noise levels score a middle to high level has also been added. Besides, the spaces that are noise sensitive have also been classified. Figure X: Noise table","title":"Noise table"},{"location":"a1.1_Process/#noise-chart","text":"The previous table showed us the average noise level and sensitivity of the various rooms. To have a better impression when the functions reach the different noise levels in specific moments of the day, the following noise-diagram is made. This gives us a good overview of which functions can be located next to each other, and which ones have to be separated by a greater distance. Figure X: Noise chart","title":"Noise chart"},{"location":"a1.1_Product/","text":"Bubble diagram The bubble diagram in Figure X consists of four types of spaces: housing, centre, facilities and recreation. While the centre for public visitors is the atrium, in which all public spaces eventually lead to, the centre for the residents is the courtyard, this is where all the spaces that are only meant for residents are connected to. During the making of the bubble diagram, noise pollution is taken into account. The spaces that have been put on the left produce noise pollution and on the right side are noise sensitive functions. Furthermore, for the placement of the entrances the visuality, accessibility, and convenience have been considered. Figure X: Bubble Diagram Metronetwork The Metro network in Figure X shows examples of the movement through the building of various residents. This graph gives us a first observation of how the connections in our bubble diagram could be used. Figure X: Metronetwerk Resident stories To test and optimise the metronetwork, we made up six imaginary stories to represent the future residents: two students, two starters and two elderly. In Figure X a day in the life of each resident is pictured. Figure X: Resident stories Matrix The matrix (problem) shows different kinds of abstract information which later will be used in the spatial computation of our site. The first part represents the connection between the different functions. As you can see, the matrix is not mirrored, this is due to a different kind of importance between the voxels. For example, is the connection between assisted living and starter housing more important (because the starters could help the residents of the assisted livings with small things) than the connection between starter housing and assisted living. In addition to the accessibility between the voxels, we added factors of graph-distance (like accessibility to the entrances and greenery), factors belonging to the euclidean-distance (silent level and noise sensitivity), and elements which can be categorized as \u2018visibility\u2019 such as daylight, direct sunlight and view. Figure X: Matrix Flowchart (summary) The flowchart as shown in Figure X represents a visualisation of all the important steps that are made within the Notebooks. On the corresponding pages, where the notebooks are explained, the section of the flowchart that is used, is shown once again. To go directly to the corresponding pages of each section, click on the following link: section 1 ; section 2 , section 3 ... (keep updating) . Figure X: Flowchart version 2 keep updating this flowchart! And make a link to a bigger version of this image.","title":"Products"},{"location":"a1.1_Product/#bubble-diagram","text":"The bubble diagram in Figure X consists of four types of spaces: housing, centre, facilities and recreation. While the centre for public visitors is the atrium, in which all public spaces eventually lead to, the centre for the residents is the courtyard, this is where all the spaces that are only meant for residents are connected to. During the making of the bubble diagram, noise pollution is taken into account. The spaces that have been put on the left produce noise pollution and on the right side are noise sensitive functions. Furthermore, for the placement of the entrances the visuality, accessibility, and convenience have been considered. Figure X: Bubble Diagram","title":"Bubble diagram"},{"location":"a1.1_Product/#metronetwork","text":"The Metro network in Figure X shows examples of the movement through the building of various residents. This graph gives us a first observation of how the connections in our bubble diagram could be used. Figure X: Metronetwerk","title":"Metronetwork"},{"location":"a1.1_Product/#resident-stories","text":"To test and optimise the metronetwork, we made up six imaginary stories to represent the future residents: two students, two starters and two elderly. In Figure X a day in the life of each resident is pictured. Figure X: Resident stories","title":"Resident stories"},{"location":"a1.1_Product/#matrix","text":"The matrix (problem) shows different kinds of abstract information which later will be used in the spatial computation of our site. The first part represents the connection between the different functions. As you can see, the matrix is not mirrored, this is due to a different kind of importance between the voxels. For example, is the connection between assisted living and starter housing more important (because the starters could help the residents of the assisted livings with small things) than the connection between starter housing and assisted living. In addition to the accessibility between the voxels, we added factors of graph-distance (like accessibility to the entrances and greenery), factors belonging to the euclidean-distance (silent level and noise sensitivity), and elements which can be categorized as \u2018visibility\u2019 such as daylight, direct sunlight and view. Figure X: Matrix","title":"Matrix"},{"location":"a1.1_Product/#flowchart-summary","text":"The flowchart as shown in Figure X represents a visualisation of all the important steps that are made within the Notebooks. On the corresponding pages, where the notebooks are explained, the section of the flowchart that is used, is shown once again. To go directly to the corresponding pages of each section, click on the following link: section 1 ; section 2 , section 3 ... (keep updating) . Figure X: Flowchart version 2 keep updating this flowchart! And make a link to a bigger version of this image.","title":"Flowchart (summary)"},{"location":"a1_planning/","text":"Planning Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning"},{"location":"a1_planning/#planning","text":"Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning"},{"location":"a2.1_Process/","text":"Voxel size - decision making For the optimal voxel size, we considered the sizes 1.5 and 1.8 due to the common use of multiples of these numbers within building constructions. To set a limit, we mainly looked at how these voxel sizes would fit into a staircase. Therefore, we investigated two types of staircases: a straight stair and a landing stair. The information we rely on is shown in the following [ Figure X (problem)](... . Stair No. Voxelsize Staircase type Voxels in x, y, z meters in x, y, z Steps Height of step Angle of staircase Stair 1 1.8 Straight 1, 2, 2 1.8, 3.6, 3.6 18 0.2 45\u00b0 Stair 2 1.5 Straight 1, 2, 2 1.5, 3.0, 3.0 15 0.2 45\u00b0 Stair 3 1.8 Landing 1, 2, 2 1.8, 3.6, 3.6 20 0.18 31\u00b0 Stair 4 1.5 Landing 1, 2, 2 1.5, 3.0, 3.0 17 0.2 32.1\u00b0 Stair 5 1.8 Straight 1, 3, 2 1.8, 5.4, 3.6 20 0.18 33.7\u00b0 Stair 6 1.5 Straight 1, 3, 2 1.5, 4.5, 3.0 17 0.176 33.7\u00b0 Stair 7 1.8 Landing 1, 3, 2 1.8, 5.4, 3.6 24 0.15 23.4\u00b0 Stair 8 1.5 Landing 1, 3, 2 1.5, 4.5, 3.0 20 0.15 23.7\u00b0 Concluding, we can see that Stair 3 and Stair 5 (both stairs within the 1.8 grid) are the optimal stairs within the voxel sizes 1.5 and 1.8. Stair 3 fits into a voxel grid of one voxel in the x-direction (1.8 m), two voxels in the y-direction (2 * 1.8 m = 3.6 m) and two voxels in the z-direction (2 * 1.8 m = 3.6 m). Stair 5 fits in a voxel grid of one voxel in the x-direction (1.8 m), three voxels in the y-direction (3 * 1.8 m = 5.4 m) and two voxels in the z-direction (2 * 1.8 m + 3.6 m). For both of these stairs, the amount of steps fits into 1.8 * 10 plus a micro voxel of 2 and the height of the steps also fits within the 18 centimeters. The visualisation of the stairs is shown in Figure X . Figure X: Stair three and five","title":"Process"},{"location":"a2.1_Process/#voxel-size-decision-making","text":"For the optimal voxel size, we considered the sizes 1.5 and 1.8 due to the common use of multiples of these numbers within building constructions. To set a limit, we mainly looked at how these voxel sizes would fit into a staircase. Therefore, we investigated two types of staircases: a straight stair and a landing stair. The information we rely on is shown in the following [ Figure X (problem)](... . Stair No. Voxelsize Staircase type Voxels in x, y, z meters in x, y, z Steps Height of step Angle of staircase Stair 1 1.8 Straight 1, 2, 2 1.8, 3.6, 3.6 18 0.2 45\u00b0 Stair 2 1.5 Straight 1, 2, 2 1.5, 3.0, 3.0 15 0.2 45\u00b0 Stair 3 1.8 Landing 1, 2, 2 1.8, 3.6, 3.6 20 0.18 31\u00b0 Stair 4 1.5 Landing 1, 2, 2 1.5, 3.0, 3.0 17 0.2 32.1\u00b0 Stair 5 1.8 Straight 1, 3, 2 1.8, 5.4, 3.6 20 0.18 33.7\u00b0 Stair 6 1.5 Straight 1, 3, 2 1.5, 4.5, 3.0 17 0.176 33.7\u00b0 Stair 7 1.8 Landing 1, 3, 2 1.8, 5.4, 3.6 24 0.15 23.4\u00b0 Stair 8 1.5 Landing 1, 3, 2 1.5, 4.5, 3.0 20 0.15 23.7\u00b0 Concluding, we can see that Stair 3 and Stair 5 (both stairs within the 1.8 grid) are the optimal stairs within the voxel sizes 1.5 and 1.8. Stair 3 fits into a voxel grid of one voxel in the x-direction (1.8 m), two voxels in the y-direction (2 * 1.8 m = 3.6 m) and two voxels in the z-direction (2 * 1.8 m = 3.6 m). Stair 5 fits in a voxel grid of one voxel in the x-direction (1.8 m), three voxels in the y-direction (3 * 1.8 m = 5.4 m) and two voxels in the z-direction (2 * 1.8 m + 3.6 m). For both of these stairs, the amount of steps fits into 1.8 * 10 plus a micro voxel of 2 and the height of the steps also fits within the 18 centimeters. The visualisation of the stairs is shown in Figure X . Figure X: Stair three and five","title":"Voxel size - decision making"},{"location":"a2.1_Product/","text":"Notebook w1: Voxelization add text (pseudocode incl. parts of script) add image (visualisation) add link to notebook Voxel amount for each function In the previous chapter ( Functional requirements ) we already presented the big table with all the information about the square meters, and thereby the needed amount of voxels, required for each function. We transformed this table to what is shown in Figure X(problem) . Now you can easily see the exact amount of voxels that is needed for each facility. To get these numbers as a result, a little equation was used, which we will explain now. First of all we needed to know how large each room (from the cash desk to toilet room) is going to be, for each function the sum is found in the column \u2018m\u00b2 per element\u2019. We could already translate these numbers into voxels. These numbers are made even by a function in google sheets, so there will be no problem if we want square rooms. The next step was to multiplicate these numbers (the square meters and the voxels) by the amount of elements that are needed (for example, there will be 100 starter housings and 3 workshop rooms), which sum up to the numbers as shown in column \u2018m\u00b2 total\u2019 and the one on the right of it. The last step was assigning the third dimension to these rooms by multiplication of it by the z-direction. This is done by the number in the column \u2018voxels (x, y)\u2019 *** the amount of floors *** 2 (2 voxels of 1,8 meters fit into 1 floor). The outcome of this table will later be used for growing the facilities. Figure X: Voxel amount per function Kangeroo add text add (rendered)","title":"Products"},{"location":"a2.1_Product/#notebook-w1-voxelization","text":"add text (pseudocode incl. parts of script) add image (visualisation) add link to notebook","title":"Notebook w1: Voxelization"},{"location":"a2.1_Product/#voxel-amount-for-each-function","text":"In the previous chapter ( Functional requirements ) we already presented the big table with all the information about the square meters, and thereby the needed amount of voxels, required for each function. We transformed this table to what is shown in Figure X(problem) . Now you can easily see the exact amount of voxels that is needed for each facility. To get these numbers as a result, a little equation was used, which we will explain now. First of all we needed to know how large each room (from the cash desk to toilet room) is going to be, for each function the sum is found in the column \u2018m\u00b2 per element\u2019. We could already translate these numbers into voxels. These numbers are made even by a function in google sheets, so there will be no problem if we want square rooms. The next step was to multiplicate these numbers (the square meters and the voxels) by the amount of elements that are needed (for example, there will be 100 starter housings and 3 workshop rooms), which sum up to the numbers as shown in column \u2018m\u00b2 total\u2019 and the one on the right of it. The last step was assigning the third dimension to these rooms by multiplication of it by the z-direction. This is done by the number in the column \u2018voxels (x, y)\u2019 *** the amount of floors *** 2 (2 voxels of 1,8 meters fit into 1 floor). The outcome of this table will later be used for growing the facilities. Figure X: Voxel amount per function","title":"Voxel amount for each function"},{"location":"a2.1_Product/#kangeroo","text":"add text add (rendered)","title":"Kangeroo"},{"location":"a2.2_Notebook1/","text":"Notebook 1: Voxelisation Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook information text Flowchart: Solar Envelope add text The flowchart as shown in Figure X is the first section of the bigger flowchart as shown in the products of the chapter Planning . It represents a visualisation of all the important steps that are made to create our voxelated model within the Notebook w1 - voxelization(problem) . The python code will be explained in detail on the next page . Figure X: Flowchart II - Voxelization keep updating this flowchart! And make a link to a bigger version of this image. additional diagrams add diagrams add text Pseudo code add text with link to notebook add pseudo codes Visualisations of the result add text Growing video add text add video Voxelcloud add text add image","title":"Notebook 1"},{"location":"a2.2_Notebook1/#notebook-1-voxelisation","text":"Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook information text","title":"Notebook 1: Voxelisation"},{"location":"a2.2_Notebook1/#flowchart-solar-envelope","text":"add text The flowchart as shown in Figure X is the first section of the bigger flowchart as shown in the products of the chapter Planning . It represents a visualisation of all the important steps that are made to create our voxelated model within the Notebook w1 - voxelization(problem) . The python code will be explained in detail on the next page . Figure X: Flowchart II - Voxelization keep updating this flowchart! And make a link to a bigger version of this image.","title":"Flowchart: Solar Envelope"},{"location":"a2.2_Notebook1/#additional-diagrams","text":"add diagrams add text","title":"additional diagrams"},{"location":"a2.2_Notebook1/#pseudo-code","text":"add text with link to notebook add pseudo codes","title":"Pseudo code"},{"location":"a2.2_Notebook1/#visualisations-of-the-result","text":"add text","title":"Visualisations of the result"},{"location":"a2.2_Notebook1/#growing-video","text":"add text add video","title":"Growing video"},{"location":"a2.2_Notebook1/#voxelcloud","text":"add text add image","title":"Voxelcloud"},{"location":"a2_configuring/","text":"Configuring Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring"},{"location":"a2_configuring/#configuring","text":"Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring"},{"location":"a3.1_Process/","text":"this page will be deleted","title":"a3.1 Process"},{"location":"a3.1_Product/","text":"this page will be deleted","title":"a3.1 Product"},{"location":"a3.2_Notebook2/","text":"clean up this mess and add the missing things Notebook 2: Solar Envelope Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook Sun analysis (year basis) Before running the Solar Envelope we researched how the surrounding buildings cast a shadow on the current site throughout the year. Here for the analysis ran every 15th day of the month at 12:00 o\u2019clock. This research shows us that if we would not increase the height of the building, it will only cast a shadow on the lower part of the building across the street (northeast) in the winter months. Figure X: Pre-sun-analysis Flowchart: Solar Envelope add text Figure X: Flowchart II - Solar envelope keep updating this flowchart! And make a link to a bigger version of this image. additional diagrams add diagrams add text Pseudo code add text with link to notebook add pseudo codes Visualisations of the result add text Growing video add text add video Voxelcloud add text add image","title":"Notebook 2"},{"location":"a3.2_Notebook2/#notebook-2-solar-envelope","text":"Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook","title":"Notebook 2: Solar Envelope"},{"location":"a3.2_Notebook2/#sun-analysis-year-basis","text":"Before running the Solar Envelope we researched how the surrounding buildings cast a shadow on the current site throughout the year. Here for the analysis ran every 15th day of the month at 12:00 o\u2019clock. This research shows us that if we would not increase the height of the building, it will only cast a shadow on the lower part of the building across the street (northeast) in the winter months. Figure X: Pre-sun-analysis","title":"Sun analysis (year basis)"},{"location":"a3.2_Notebook2/#flowchart-solar-envelope","text":"add text Figure X: Flowchart II - Solar envelope keep updating this flowchart! And make a link to a bigger version of this image.","title":"Flowchart: Solar Envelope"},{"location":"a3.2_Notebook2/#additional-diagrams","text":"add diagrams add text","title":"additional diagrams"},{"location":"a3.2_Notebook2/#pseudo-code","text":"add text with link to notebook add pseudo codes","title":"Pseudo code"},{"location":"a3.2_Notebook2/#visualisations-of-the-result","text":"add text","title":"Visualisations of the result"},{"location":"a3.2_Notebook2/#growing-video","text":"add text add video","title":"Growing video"},{"location":"a3.2_Notebook2/#voxelcloud","text":"add text add image","title":"Voxelcloud"},{"location":"a3.2_Notebook4/","text":"Notebook 4: Generative Relations mcda Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook For the generation of the agent based design the following matrix has been made based on the agent criterias, this has been used in the definitive script. As you can see, we have focused on the following aspects: the connection between the spaces and the different entrances, the sun access, sky view, the silent level active (which means how little noise the facilities produce) and the noise sensitivity (which we will use for both the internal and external noise). Space area means the estimated amount of voxels (3,6m x 3,6m x 3,6m) each function needs and with the column initial location we manually indicate the specific position for the entrances. Figure X: CSV - Matrix The entrances that we have determined are shown in Figure X . The most public entrances have been placed on the most busy road (Vijverhofstraat). These are the entrances for the atrium, supermarket and cinema, arcade and caf\u00e9/restaurant/pub. The entrances to the courtyard and the atrium carry contrasting functions of public and private. Nevertheless, we want these spaces to have a strong connection which is simulated by placing them opposite of each other, whereby the entrance of the courtyard is situated at the more peaceful side, namely the north east side along the Schoterbosstraat . Subsequently the public library is situated at Teilingerstraat and the car parking at Zomerhofstraat . Both streets that are less busy than Vijverhofstraat , but are situated close to other the public entrances that have been appointed above. And lastly, the trash room is placed on the Teilingerstraat . In addition, sound pollution, produced by the internal spaces inside the building as well as the sound pollution produced by the outdoors traffic, has been taken into account when the entrances were placed. The placement of the entrances divide the building into a sound producing side and a more quiet side. Figure X: Entrance sketch Flowchart In Figure X the flowchart of notebook generative relations mcda is shown, in which the global steps that have been executed are presented. In the following diagrams we will zoom in on each criteria where the main steps have been visualized and are explained. Figure X: Flowchart notebook 4 Additional diagrams In the following diagrams we will zoom in on each criteria where the main steps have been visualized and are explained. Diagram Closeness : The location of the seed agents is calculated randomly. When the initial location has been determined the different seed agents will be attracted to each other, based on the closeness matrix. The seed agents will eventually grow towards the attracted seed. Diagram Entrances : The specific initial location of the entrances have been chosen manually, based on the entrance map. When the initial location is calculated randomly and is placed it will grow towards the attracted entrance seed, based on entrance accessibility matrix. Diagram Floor preference : A column of the building will be cut out and will get a range of distance values. When the initial location has been determined the different seed agents will be attracted to their desired floor preference, based on the floor preference matrix. The only floors that are preferred are 1 and 0 or nothing. The seed agents will grow towards the attracted floor preference. Diagram Internal noise : The location of the seed agents is calculated randomly. The amount of silence the agents produce will be calculated and will be compared to the noise sensitivity property. The agents that are sensitive for noise will grow away from the agents that create a lot of noise. Diagram External noise : The amount of external noise around the building will be determined.The location of the seed agents is calculated randomly. When the initial location has been determined the noise sensitivity property, from the matrix will be compared to the external noise values. The agents that are sensitive to noise will grow away from the noisy facades. Diagram Sun access : The amount of sun access of the building will be determined. The location of the seed agents is calculated randomly. When the initial location has been determined the different seed agents will be attracted to an amount of sun access, based on the sun access matrix. The seed agents will eventually grow towards the facade with the prefered amount of sun access. Diagram Sky view : The amount of sky view of the building will be determined.The location of the seed agents is calculated randomly. When the initial location has been determined the different seed agents will be attracted to an amount of sky view, based on the sky view matrix. The seed agents will eventually grow towards the prefered amount of sky view access. Pseudocode For a better understanding of the code we wrote a pseudocode. The notebook, and the other notebooks, can be found here . Closeness while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Entrances if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Internal noise if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations define noise range initialize noise sources for each agent: extract agent locations retrieve the silent level of the agent mapping the [0,1] values to noise level (db) for each agent location: append the noise source information convert noise source information to numpy create full lattice extract the coordinates of the centroid of all voxel extract voxel indices of all voxels initializing the sum lattice of noise for each source of noise: create distance lattice: for every centroid compute the euclidean distance compute the noise lattice from dist lattice summing the amount of noise normalizing the noise values list the environment information layers while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance, noise and preference data append best voxel to agent list Floor preference if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations initialize floor lattice cut out a column specify a range array based on the number of voxels in the column compute the distances based on the range column compute the floor lattice return the floor lattice put the floor lattice in a dictionary while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: heck which neighs are available grade those neighs on distance and preference data append best voxel to agent list Internal sun access Loading the lattice from csv list the environment information layers if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Sky view Loading the lattice from csv list the environment information layers if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list External noise Loading the lattice from csv list the environment information layers if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Visualisations of the result Last but not least: the results . The results are visualized in a video and in a voxel cloud Growing video Video here Voxel cloud Figure X: Visualisation notebook 4","title":"Notebook 4"},{"location":"a3.2_Notebook4/#notebook-4-generative-relations-mcda","text":"Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook For the generation of the agent based design the following matrix has been made based on the agent criterias, this has been used in the definitive script. As you can see, we have focused on the following aspects: the connection between the spaces and the different entrances, the sun access, sky view, the silent level active (which means how little noise the facilities produce) and the noise sensitivity (which we will use for both the internal and external noise). Space area means the estimated amount of voxels (3,6m x 3,6m x 3,6m) each function needs and with the column initial location we manually indicate the specific position for the entrances. Figure X: CSV - Matrix The entrances that we have determined are shown in Figure X . The most public entrances have been placed on the most busy road (Vijverhofstraat). These are the entrances for the atrium, supermarket and cinema, arcade and caf\u00e9/restaurant/pub. The entrances to the courtyard and the atrium carry contrasting functions of public and private. Nevertheless, we want these spaces to have a strong connection which is simulated by placing them opposite of each other, whereby the entrance of the courtyard is situated at the more peaceful side, namely the north east side along the Schoterbosstraat . Subsequently the public library is situated at Teilingerstraat and the car parking at Zomerhofstraat . Both streets that are less busy than Vijverhofstraat , but are situated close to other the public entrances that have been appointed above. And lastly, the trash room is placed on the Teilingerstraat . In addition, sound pollution, produced by the internal spaces inside the building as well as the sound pollution produced by the outdoors traffic, has been taken into account when the entrances were placed. The placement of the entrances divide the building into a sound producing side and a more quiet side. Figure X: Entrance sketch","title":"Notebook 4: Generative Relations mcda"},{"location":"a3.2_Notebook4/#flowchart","text":"In Figure X the flowchart of notebook generative relations mcda is shown, in which the global steps that have been executed are presented. In the following diagrams we will zoom in on each criteria where the main steps have been visualized and are explained. Figure X: Flowchart notebook 4","title":"Flowchart"},{"location":"a3.2_Notebook4/#additional-diagrams","text":"In the following diagrams we will zoom in on each criteria where the main steps have been visualized and are explained. Diagram Closeness : The location of the seed agents is calculated randomly. When the initial location has been determined the different seed agents will be attracted to each other, based on the closeness matrix. The seed agents will eventually grow towards the attracted seed. Diagram Entrances : The specific initial location of the entrances have been chosen manually, based on the entrance map. When the initial location is calculated randomly and is placed it will grow towards the attracted entrance seed, based on entrance accessibility matrix. Diagram Floor preference : A column of the building will be cut out and will get a range of distance values. When the initial location has been determined the different seed agents will be attracted to their desired floor preference, based on the floor preference matrix. The only floors that are preferred are 1 and 0 or nothing. The seed agents will grow towards the attracted floor preference. Diagram Internal noise : The location of the seed agents is calculated randomly. The amount of silence the agents produce will be calculated and will be compared to the noise sensitivity property. The agents that are sensitive for noise will grow away from the agents that create a lot of noise. Diagram External noise : The amount of external noise around the building will be determined.The location of the seed agents is calculated randomly. When the initial location has been determined the noise sensitivity property, from the matrix will be compared to the external noise values. The agents that are sensitive to noise will grow away from the noisy facades. Diagram Sun access : The amount of sun access of the building will be determined. The location of the seed agents is calculated randomly. When the initial location has been determined the different seed agents will be attracted to an amount of sun access, based on the sun access matrix. The seed agents will eventually grow towards the facade with the prefered amount of sun access. Diagram Sky view : The amount of sky view of the building will be determined.The location of the seed agents is calculated randomly. When the initial location has been determined the different seed agents will be attracted to an amount of sky view, based on the sky view matrix. The seed agents will eventually grow towards the prefered amount of sky view access.","title":"Additional diagrams"},{"location":"a3.2_Notebook4/#pseudocode","text":"For a better understanding of the code we wrote a pseudocode. The notebook, and the other notebooks, can be found here . Closeness while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Entrances if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Internal noise if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations define noise range initialize noise sources for each agent: extract agent locations retrieve the silent level of the agent mapping the [0,1] values to noise level (db) for each agent location: append the noise source information convert noise source information to numpy create full lattice extract the coordinates of the centroid of all voxel extract voxel indices of all voxels initializing the sum lattice of noise for each source of noise: create distance lattice: for every centroid compute the euclidean distance compute the noise lattice from dist lattice summing the amount of noise normalizing the noise values list the environment information layers while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance, noise and preference data append best voxel to agent list Floor preference if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations initialize floor lattice cut out a column specify a range array based on the number of voxels in the column compute the distances based on the range column compute the floor lattice return the floor lattice put the floor lattice in a dictionary while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: heck which neighs are available grade those neighs on distance and preference data append best voxel to agent list Internal sun access Loading the lattice from csv list the environment information layers if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list Sky view Loading the lattice from csv list the environment information layers if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list External noise Loading the lattice from csv list the environment information layers if agent location is assigned in matrix, then add to list of agent locations else calculate agent location randomly and add to list of agent locations while i < maximal amount of space area: for each agent: calculate a closeness lattice to the seed voxel select neighbours: check which neighs are available grade those neighs on distance and preference data append best voxel to agent list","title":"Pseudocode"},{"location":"a3.2_Notebook4/#visualisations-of-the-result","text":"Last but not least: the results . The results are visualized in a video and in a voxel cloud","title":"Visualisations of the result"},{"location":"a3.2_Notebook4/#growing-video","text":"Video here","title":"Growing video"},{"location":"a3.2_Notebook4/#voxel-cloud","text":"Figure X: Visualisation notebook 4","title":"Voxel cloud"},{"location":"a3_massing/","text":"Massing Here you should include the process and product of your 3rd activity: Massing Title Massing (process): Composition (product) Objective Logically place the functional spaces in between bridges within the building envelope. Procedure Compute a Solar Envelope, i.e. an envelope of cuboids/voxels, some of which are removed because they are in the way of the neighbouring buildings receiving some standard/minimum level of direct sunlight. Fit the circulation manifold into the solar envelope. From the standing platforms corresponding to functional spaces, grow them into voxel clouds within your voxelated envelope. Colour the voxel clouds according to their functionalities.","title":"Massing"},{"location":"a3_massing/#massing","text":"Here you should include the process and product of your 3rd activity: Massing Title Massing (process): Composition (product) Objective Logically place the functional spaces in between bridges within the building envelope. Procedure Compute a Solar Envelope, i.e. an envelope of cuboids/voxels, some of which are removed because they are in the way of the neighbouring buildings receiving some standard/minimum level of direct sunlight. Fit the circulation manifold into the solar envelope. From the standing platforms corresponding to functional spaces, grow them into voxel clouds within your voxelated envelope. Colour the voxel clouds according to their functionalities.","title":"Massing"},{"location":"a4.1_Process/","text":"this page will be deleted","title":"a4.1 Process"},{"location":"a4.1_Product/","text":"this page will be deleted","title":"a4.1 Product"},{"location":"a4.2_Notebook5/","text":"Notebook 5: xxx Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook information text Flowchart: xxx add text The flowchart as shown in Figure X is the first section of the bigger flowchart as shown in the products of the chapter Planning . It represents a visualisation of all the important steps that are made to create our voxelated model within the Notebook w1 - voxelization(problem) . The python code will be explained in detail on the next page . Figure X: Flowchart II - Voxelization keep updating this flowchart! And make a link to a bigger version of this image. additional diagrams add diagrams add text Pseudo code add text with link to notebook add pseudo codes Visualisations of the result add text Growing video add text add video Voxelcloud add text add image","title":"Notebook 5"},{"location":"a4.2_Notebook5/#notebook-5-xxx","text":"Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook information text","title":"Notebook 5: xxx"},{"location":"a4.2_Notebook5/#flowchart-xxx","text":"add text The flowchart as shown in Figure X is the first section of the bigger flowchart as shown in the products of the chapter Planning . It represents a visualisation of all the important steps that are made to create our voxelated model within the Notebook w1 - voxelization(problem) . The python code will be explained in detail on the next page . Figure X: Flowchart II - Voxelization keep updating this flowchart! And make a link to a bigger version of this image.","title":"Flowchart: xxx"},{"location":"a4.2_Notebook5/#additional-diagrams","text":"add diagrams add text","title":"additional diagrams"},{"location":"a4.2_Notebook5/#pseudo-code","text":"add text with link to notebook add pseudo codes","title":"Pseudo code"},{"location":"a4.2_Notebook5/#visualisations-of-the-result","text":"add text","title":"Visualisations of the result"},{"location":"a4.2_Notebook5/#growing-video","text":"add text add video","title":"Growing video"},{"location":"a4.2_Notebook5/#voxelcloud","text":"add text add image","title":"Voxelcloud"},{"location":"a4.2_Notebook6/","text":"Notebook 1: XXX Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook information text Flowchart: XXX add text Figure X: Flowchart IIII - XXX keep updating this flowchart! And make a link to a bigger version of this image. additional diagrams add diagrams add text Pseudo code add text with link to notebook add pseudo codes Visualisations of the result add text Growing video add text add video Voxelcloud add text add image","title":"Notebook 6"},{"location":"a4.2_Notebook6/#notebook-1-xxx","text":"Task List Text Flowchart Charts Growing video voxel cloud Psuedocode Notebook information text","title":"Notebook 1: XXX"},{"location":"a4.2_Notebook6/#flowchart-xxx","text":"add text Figure X: Flowchart IIII - XXX keep updating this flowchart! And make a link to a bigger version of this image.","title":"Flowchart: XXX"},{"location":"a4.2_Notebook6/#additional-diagrams","text":"add diagrams add text","title":"additional diagrams"},{"location":"a4.2_Notebook6/#pseudo-code","text":"add text with link to notebook add pseudo codes","title":"Pseudo code"},{"location":"a4.2_Notebook6/#visualisations-of-the-result","text":"add text","title":"Visualisations of the result"},{"location":"a4.2_Notebook6/#growing-video","text":"add text add video","title":"Growing video"},{"location":"a4.2_Notebook6/#voxelcloud","text":"add text add image","title":"Voxelcloud"},{"location":"a4.2_Results/","text":"Floorplans insert text Floorplans - residences insert text insert images Floorplans - stencils insert text insert images Floorplans - total floors insert text insert images Renders insert text insert images","title":"Results"},{"location":"a4.2_Results/#floorplans","text":"insert text","title":"Floorplans"},{"location":"a4.2_Results/#floorplans-residences","text":"insert text insert images","title":"Floorplans - residences"},{"location":"a4.2_Results/#floorplans-stencils","text":"insert text insert images","title":"Floorplans - stencils"},{"location":"a4.2_Results/#floorplans-total-floors","text":"insert text insert images","title":"Floorplans - total floors"},{"location":"a4.2_Results/#renders","text":"insert text insert images","title":"Renders"},{"location":"a4_forming/","text":"Forming Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"a4_forming/#forming","text":"Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"about/","text":"About Include your name, the tutors names, and the course name here This web portal has been made for the course BK7083 \u2018\u2019Computational Design Studio\u2019\u2019 given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. The course was guided by Dr. Ir. P. Nourian, Ir. H. Hoogenboom and Ir. S. Azadi. This web portal documents the design process made by group 2, which concludes the following students: Name Role Jiri Puzzle Solver Milou Journalist Nancy Reflectionist","title":"About"},{"location":"about/#about","text":"Include your name, the tutors names, and the course name here This web portal has been made for the course BK7083 \u2018\u2019Computational Design Studio\u2019\u2019 given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. The course was guided by Dr. Ir. P. Nourian, Ir. H. Hoogenboom and Ir. S. Azadi. This web portal documents the design process made by group 2, which concludes the following students: Name Role Jiri Puzzle Solver Milou Journalist Nancy Reflectionist","title":"About"},{"location":"documenting/folder_structure/","text":"Folder Structure The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/folder_structure/#folder-structure","text":"The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/guidelines/","text":"Guidelines File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/guidelines/#guidelines","text":"File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/instructions/","text":"Documenting Instructions Installation Install Conda You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda). Create documentation environment Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml Start Work on Documentation After finishing your work on documentation you need to shutdown the server and deactivate the environment. Activate the Environment Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in paranthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template % Run the Local Server Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site. Writing Your Documentation In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations Finish Work on Documentation Server Shut Down To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down... Deactivate Environment After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate Deployment of the Documentation Site Build and Deploy to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository. Setup GitHub Pages For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Instructions"},{"location":"documenting/instructions/#documenting-instructions","text":"","title":"Documenting Instructions"},{"location":"documenting/instructions/#installation","text":"","title":"Installation"},{"location":"documenting/instructions/#install-conda","text":"You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda).","title":"Install Conda"},{"location":"documenting/instructions/#create-documentation-environment","text":"Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml","title":"Create documentation environment"},{"location":"documenting/instructions/#start-work-on-documentation","text":"After finishing your work on documentation you need to shutdown the server and deactivate the environment.","title":"Start Work on Documentation"},{"location":"documenting/instructions/#activate-the-environment","text":"Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in paranthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template %","title":"Activate the Environment"},{"location":"documenting/instructions/#run-the-local-server","text":"Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site.","title":"Run the Local Server"},{"location":"documenting/instructions/#writing-your-documentation","text":"In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations","title":"Writing Your Documentation"},{"location":"documenting/instructions/#finish-work-on-documentation","text":"","title":"Finish Work on Documentation"},{"location":"documenting/instructions/#server-shut-down","text":"To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down...","title":"Server Shut Down"},{"location":"documenting/instructions/#deactivate-environment","text":"After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate","title":"Deactivate Environment"},{"location":"documenting/instructions/#deployment-of-the-documentation-site","text":"","title":"Deployment of the Documentation Site"},{"location":"documenting/instructions/#build-and-deploy","text":"to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository.","title":"Build and Deploy"},{"location":"documenting/instructions/#setup-github-pages","text":"For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Setup GitHub Pages"},{"location":"index/bibliography/","text":"Bibliography Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself. Home: Stichting ZOHOCITIZENS Ondernemerscollectief. (2018, 6 april). Wat is ZOHO. Geraadpleegd op 10 december 2020, van https://zohorotterdam.nl/over-zoho/","title":"Bibliography"},{"location":"index/bibliography/#bibliography","text":"Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself. Home: Stichting ZOHOCITIZENS Ondernemerscollectief. (2018, 6 april). Wat is ZOHO. Geraadpleegd op 10 december 2020, van https://zohorotterdam.nl/over-zoho/","title":"Bibliography"},{"location":"index/figures/","text":"Figures Here you should include all of your figures and links to the pages that they have been used in. ![title](../img/ name.png Option 1: Figure 1: Given design goals. To be found in Planning - Process . Option 2: Figure 1: Given design goals. To be found in [Planning - Process](..\\a1.1_Process.md). You can embed your only videos like this:","title":"Figures"},{"location":"index/figures/#figures","text":"Here you should include all of your figures and links to the pages that they have been used in. ![title](../img/ name.png Option 1: Figure 1: Given design goals. To be found in Planning - Process . Option 2: Figure 1: Given design goals. To be found in [Planning - Process](..\\a1.1_Process.md). You can embed your only videos like this:","title":"Figures"},{"location":"index/presentations/","text":"Presentations Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"index/presentations/#presentations","text":"Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"index/scripts/","text":"Scripts Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: edges = [] for cell_neigh in cell_neighbors : cell = cell_neigh [ 0 ] for neigh in cell_neigh [ 1 :]: if neigh != - 1 and neigh > cell : edges . append (( cell , neigh )) Notebook 4 For more information about Notebook 4 , see Massing - Notebook 4 .","title":"Scripts"},{"location":"index/scripts/#scripts","text":"Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: edges = [] for cell_neigh in cell_neighbors : cell = cell_neigh [ 0 ] for neigh in cell_neigh [ 1 :]: if neigh != - 1 and neigh > cell : edges . append (( cell , neigh ))","title":"Scripts"},{"location":"index/scripts/#notebook-4","text":"For more information about Notebook 4 , see Massing - Notebook 4 .","title":"Notebook 4"},{"location":"notebooks/placeholder_w1_Notebook/","text":"{\\rtf1}","title":"placeholder w1 Notebook"},{"location":"notebooks/placeholder_w2_Notebook/","text":"{\\rtf1}","title":"placeholder w2 Notebook"},{"location":"notebooks/placeholder_w3_Notebook/","text":"{\\rtf1}","title":"placeholder w3 Notebook"},{"location":"notebooks/placeholder_w4_Notebook/","text":"{\\rtf1}","title":"placeholder w4 Notebook"},{"location":"notebooks/w4_generative_relations_mcda.3/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Generative Relations: MCDA In this workshop, we will learn how enable agents to utilize MCDA (Multi Criteria Decision Analyses) in their spatial behaviors. 0. Initialization 0.1. Load required libraries import os import matplotlib as mpl import matplotlib.pyplot as plt from matplotlib import cm import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx import pandas as pd import scipy as sp np . random . seed ( 0 ) # extra import function def lattice_from_csv ( file_path ): # read metadata meta_df = pd . read_csv ( file_path , nrows = 3 ) shape = np . array ( meta_df [ 'shape' ]) unit = np . array ( meta_df [ 'unit' ]) minbound = np . array ( meta_df [ 'minbound' ]) # read lattice lattice_df = pd . read_csv ( file_path , skiprows = 5 ) # create the buffer buffer = np . array ( lattice_df [ 'value' ]) . reshape ( shape ) # create the lattice l = tg . to_lattice ( buffer , minbound = minbound , unit = unit ) return l 0.2. Define the Neighborhood (Stencil) # creating neighborhood definition stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the center to zero stencil . set_index ([ 0 , 0 , 0 ], 0 ) 0.3. Load the envelope lattice as the avialbility lattice # loading the lattice from csv lattice_path = os . path . relpath ( '../data/voxelated_model_3_6.csv' ) avail_lattice = lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice ) 0.4. Load Agents Information # loading program (agents information) from CSV prgm_path = os . path . relpath ( '../data/Matrix9.csv' ) agn_info = np . genfromtxt ( prgm_path , delimiter = ',' )[ 1 :, 1 :] agn_ids = agn_info [:, 0 ] # extract agent ids agn_ids = agn_info [:, 0 ] # extract agent preferences agn_prefs = agn_info [:, 1 : 27 ] # extract agent space area agn_space_area = agn_info [:, 27 ] # extract the initial location agn_initial_loc = agn_info [:, 28 ] . astype ( int ) #print(agn_prefs.shape) #print(agn_ids_space) #print(agn_ids_entrance) #print(agn_prefs) #print(agn_initial_loc) agn_data = pd . read_csv ( prgm_path ) agn_data . loc [ 1 ][ \"sun_access\" ] 1.0 agn_data . loc [ 0 ] space_name Atrium space_id 0 Atrium 1 Courtyard 1 Starter_housing 0 Assisted_living 0 Student_housing 0 Supermarket 0.2 Cafe_restaurant_pub 0.2 Cinema 0.2 Arcade 0.2 Workshops 0.2 Community_center 0 Co_cooking_center 0 Library 0.2 Gym 0 Laundry_room 0 Ent_access_courtyard 0 Ent_access_trashroom 0 Ent_access_parking 0 Ent_access_supermarket 0 Ent_access_library 0 Ent_access_cinema_cafe_arcade 0 Ent_access_atrium 1 sun_access 1 sky_view 0 silent_level_active 0.6 noise_sensitivity 0 space_area 188 initial_loc -1 0 floor 1 1 floor 0 Name: 0, dtype: object 0.5. Initialize environment information layers from Sun Access Lattice, Sky View Lattice, Noise Lattice, # loading the lattice from csv sun_acc_path = os . path . relpath ( '../data/solar_access_3_6.csv' ) sun_acc_lattice = lattice_from_csv ( sun_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info_dict = { \"sun_access\" : sun_acc_lattice , #\"test_layer\": test_latice } env_info = [ sun_acc_lattice ] # loading the lattice from csv skyview_acc_path = os . path . relpath ( '../data/skyview_3_6.csv' ) skyview_acc_lattice = lattice_from_csv ( sun_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info_dict = { \"sky_view\" : skyview_acc_lattice , #\"test_layer\": test_latice } env_info = [ skyview_acc_lattice ] # loading the lattice from csv external_noise_acc_path = os . path . relpath ( '../data/sound_3_6.csv' ) external_noise_acc_lattice = lattice_from_csv ( sun_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info_dict = { \"noise_sensitivity \" : external_noise_acc_lattice , #\"test_layer\": test_latice } env_info = [ external_noise_acc_lattice ] 1. ABM Simulation 1.1. Initialize the Agents # initialize the occupation lattice occ_lattice = avail_lattice * 0 - 1 # Finding the index of the available voxels in avail_lattice avail_flat = avail_lattice . flatten () avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # count the number of spaces (rows) and intiialize an agent for each space agn_num = len ( agn_info ) # choose the initial location of agents randomly select_id = np . random . choice ( len ( avail_index ), agn_num , replace = False ) agn_origins = avail_index [ select_id ] # adding the origins to the agents locations agn_locs = [] # for each agent origin ... for a_id , a_origin , a_init_loc in zip ( agn_ids , agn_origins , agn_initial_loc ): if a_init_loc == - 1 : final_a_origin = a_origin else : final_a_origin = np . unravel_index ( a_init_loc , avail_lattice . shape ) # add the origin to the list of agent locations agn_locs . append ([ final_a_origin ]) # set the origin in availablity lattice as 0 (UNavailable) avail_lattice [ tuple ( final_a_origin )] = 0 # set the origin in occupation lattice as the agent id (a_id) occ_lattice [ tuple ( final_a_origin )] = int ( a_id ) # this is now based on the id of the agent in the program print ( select_id ) print ( init_avail_lattice . sum ()) print ( avail_lattice . sum ()) print ( a_id ) [1817 5286 7331 6136 7187 6638 4502 5686 2232 451 7436 356 5768 2635 162 6249 4995 1422 6328 878 6190 7138] 7864 7842 24.0 def floor_level_lattice ( target_floor , avail_lattice ): # initialize the floor lattice floor_lattice = avail_lattice * 0.0 # cut a single column out single_column = floor_lattice [ 0 , 0 ,:] # specify a range array based on the number of voxels in th ecolumn range_column = np . arange ( single_column . size ) # compute the distances based on the range column distance_column = ( 1 / ( np . abs ( range_column - target_floor ) + 1 ) ** 2 ) . reshape ( 1 , 1 , avail_lattice . shape [ 2 ]) # compute the floor lattice floor_lattice += distance_column # return the floor lattice return floor_lattice ground_floor_lattice = floor_level_lattice ( 0 , avail_lattice ) first_floor_lattice = floor_level_lattice ( 1 , avail_lattice ) env_info_dict [ \"0 floor\" ] = ground_floor_lattice env_info_dict [ \"1 floor\" ] = first_floor_lattice # visualizing the info lattices p = pv . Plotter ( notebook = True ) info_val_list = list ( env_info_dict . values ()) info_key_list = env_info_dict . keys () for i , k in enumerate ( info_key_list ): print ( i , k ) base_lattice = info_val_list [ 0 ] # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions: shape because we want to inject our values grid . dimensions = base_lattice . shape # The bottom left corner of the data set grid . origin = base_lattice . minbound # These are the cell sizes along each axis grid . spacing = base_lattice . unit def create_mesh ( value ): f = int ( value ) lattice = info_val_list [ f ] # Add the data values to the cell data grid . point_arrays [ \"info\" ] = lattice . flatten ( order = \"F\" ) # Flatten the Lattice # adding the volume opacity = np . array ([ 0 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 ]) * 1.5 p . add_volume ( grid , cmap = \"coolwarm\" , name = 'sphere' , clim = [ 0.0 , 1.0 ], opacity = opacity , shade = True ) return p . add_slider_widget ( create_mesh , [ 0 , len ( info_val_list ) - 1 ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) 0 noise_sensitivity 1 0 floor 2 1 floor var element = $('#6b52fea4-2676-4f6e-bb77-afa62cf4a057'); {\"model_id\": \"3354754db3a445fc96188cb2edc04b73\", \"version_major\": 2, \"version_minor\": 0} [(246.73679328932968, 145.93679328932967, 225.13679328932966), (48.60000000000001, -52.2, 27.0), (0.0, 0.0, 1.0)] def dynamic_noise_lattice ( agn_locs , avail_lattice ): # define the noise range noise_range = [ 10.0 , 60.0 ] # initialize noise sources noise_src_points = [] noise_src_levels = [] # iterate over agents for a_id in range ( len ( agn_locs )): # extract agent locations a_locs = agn_locs [ a_id ] # retrieve the silent level of the agent a_noise_level_mapped = 1 - agn_data . loc [ a_id ][ \"silent_level_active\" ] # mapping the [0,1] values to noise level (db) a_noise_level = a_noise_level_mapped * ( noise_range [ 1 ] - noise_range [ 0 ]) + noise_range [ 0 ] # for each agent location for a_loc in a_locs : # append the noise source information noise_src_points . append ( a_loc ) noise_src_levels . append ( a_noise_level ) # convert to numpy array noise_src_points = np . array ( noise_src_points ) # create full lattice full_lattice = avail_lattice * 0 + 1 # extract the coordiantes of the centroid of all voxel vox_centroids = full_lattice . centroids # extract voxel indices of all voxels vox_indices = np . array ( np . where ( full_lattice == 1 )) . T # initializing the sum lattice of noise sum_noise_lats = avail_lattice * 0.0 # for each source of noise for src_point , src_level in zip ( noise_src_points , noise_src_levels ): # initialize the occupation lattice dist_latice = avail_lattice * 0.0 for cen , ind in zip ( vox_centroids , vox_indices ): # compute the euclidian distance dist_latice [ tuple ( ind )] = sp . spatial . distance . euclidean ( cen , src_point ) # computing the noise lattice from dist lattice noise_latice = src_level - 20 * np . log10 ( dist_latice ) - 8 # summing sum_noise_lats += np . power ( 10 , noise_latice / 10.0 ) # computing the final aggregation agg_noise_lats = 10 * np . log10 ( sum_noise_lats ) # normalizing the noise values normalized_silence_lattice = 1 - ( agg_noise_lats - np . min ( agg_noise_lats )) / ( np . max ( agg_noise_lats ) - np . min ( agg_noise_lats )) return normalized_silence_lattice 1.2. Running the Simulation # floor_info = {\"0 floor\" and \"1 floor\" : floor_level_lattice, dynamic_info = { \"noise_sensitivity \" : dynamic_noise_lattice , } # make a deep copy of occupation lattice cur_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # initialzing the list of frames frames = [ cur_occ_lattice ] # setting the time variable to 0 t = 0 n_frames = max ( agn_space_area ) # Simulation Loop # main feedback loop of the simulation (for each time step ...) while t < n_frames : # update the info lattices # iterate over dynamic lattices for info_key , info_function in dynamic_info . items (): env_info_dict [ info_key ] = info_function ( agn_locs , avail_lattice ) # env_info_dict[\"noise_sensitivity \"] = dynamic_noise_lattice(agn_locs, avail_lattice) # Agent Loop # for each agent ... for a_id in range ( agn_num ): # retrieve the list of the locations of the current agent a_locs = agn_locs [ a_id ] # Make sure there are no more voxels than specified (area check) if len ( a_locs ) < agn_data . loc [ a_id ][ \"space_area\" ]: # agn_space_area[a_id]: # initialize the list of free neighbours free_neighs = [] # Location loop # for each location of the agent for loc in a_locs : # retrieve the list of neighbours of the agent based on the stencil neighs = avail_lattice . find_neighbours_masked ( stencil , loc = loc ) # for each neighbour ... for n in neighs : # compute 3D index of neighbour neigh_3d_id = np . unravel_index ( n , avail_lattice . shape ) # if the neighbour is available... if avail_lattice [ neigh_3d_id ]: # add the neighbour to the list of free neighbours free_neighs . append ( neigh_3d_id ) # check if found any free neighbour if len ( free_neighs ) > 0 : # convert free neighbours to a numpy array free_neighs = np . array ( free_neighs ) # retrieving the entrance access value of the free neighbours neigh_vals = [] # retrieve agent preferences a_pref = agn_prefs [ a_id ] a_pref_dict = agn_data . loc [ a_id ] . to_dict () # Neighbour Evaluation Loop for neigh in free_neighs : neigh_value = 1.0 # for every lattice in the environment informations for info_key , info_lattice in env_info_dict . items (): # Here we utilise Fuzzy Logics to be able to compare different layers # of environmental information and evaluate the voxel for the agent. # This method is introduced, and generalised in Pirouz Nourian dissertation: # section 5.7.3, pp. 201-208, eq. 57. You can refer to this section for # comprehensive mathematical details. vox_val = info_lattice [ tuple ( neigh )] agn_vox_val = np . power ( vox_val , a_pref_dict [ info_key ]) neigh_value *= agn_vox_val # add the neighbour value to the list of values neigh_vals . append ( neigh_value ) # convert to numpy array neigh_vals = np . array ( neigh_vals ) # select the neighbour with highest value selected_int = np . argmax ( neigh_vals ) # find 3D intiger index of selected neighbour selected_neigh_3d_id = tuple ( free_neighs [ selected_int ] . T ) # find the location of the newly selected neighbour selected_neigh_loc = np . array ( selected_neigh_3d_id ) . flatten () # add the newly selected neighbour location to agent locations agn_locs [ a_id ] . append ( selected_neigh_loc ) # set the newly selected neighbour as UNavailable (0) in the availability lattice avail_lattice [ selected_neigh_3d_id ] = 0 # set the newly selected neighbour as OCCUPIED by current agent # (-1 means not-occupied so a_id) occ_lattice [ selected_neigh_3d_id ] = a_id # constructing the new lattice new_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # adding the new lattice to the list of frames frames . append ( new_occ_lattice ) # adding one to the time counter t += 1 1.3. Visualizing the simulation p = pv . Plotter ( notebook = True ) base_lattice = frames [ 0 ] # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) #Make a dictonary for the annotations space_list = { 0 : \"Atrium\" , 1 : \"Courtyard\" , 2 : \"Starter housing\" , 3 : \"Assisted living\" , 4 : \"Student housing\" , 5 : \"Supermarket\" , 6 : \"Cafe restaurant pub\" , 7 : \"Cinema\" , 8 : \"Arcade\" , 9 : \"Workshops\" , 10 : \"Community center\" , 11 : \"Co cooking center\" , 12 : \"Library\" , 13 : \"Gym\" , 14 : \"Laundry room\" , 15 : \"Green_roof\" , 16 : \"Entrance courtyard\" , 17 : \"Entrance trashroom\" , 18 : \"Entrance parking\" , 19 : \"Entrance supermarket\" , 20 : \"Entrance library\" , 21 : \"Entrance cinema cafe arcade\" , 22 : \"Entrance atrium\" , } #make a dictionary for sargs = dict ( shadow = True , n_labels = 0 , italic = False , fmt = \" %.0f \" , font_family = \"arial\" , height = 0.6 , vertical = True , position_x = 1.05 , position_y = 1 ) def create_mesh ( value ): f = int ( value ) lattice = frames [ f ] # Add the data values to the cell data grid . cell_arrays [ \"Agents\" ] = lattice . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , agn_num - 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = True , annotations = space_list , scalar_bar_args = sargs , cmap = \"tab20b\" ) return p . add_slider_widget ( create_mesh , [ 0 , n_frames ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.2 ), pointb = ( 0.9 , 0.2 )) p . show ( use_ipyvtk = True ) var element = $('#b2061e6f-f795-4b0b-bfd5-0f97aee1d9c8'); {\"model_id\": \"c70cb8a06abe43358186a578e15e3a14\", \"version_major\": 2, \"version_minor\": 0} [(253.02459757597026, 152.2245973852354, 231.42459588319835), (48.60000133514404, -52.19999885559082, 26.99999964237213), (0.0, 0.0, 1.0)] 2.3. Saving lattice frames in CSV for i , lattice in enumerate ( frames ): csv_path = os . path . relpath ( '../data/abm_mcda/abm_f_' + f ' { i : 03 } ' + '.csv' ) lattice . to_csv ( csv_path ) Credits __author__ = \"Shervin Azadi and Pirouz Nourian\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/spatial_computing_workshops\" __summary__ = \"Spatial Computing Design Studio Workshop on MCDA and Path Finding for Generative Spatial Relations\"","title":"W4 generative relations mcda.3"},{"location":"notebooks/w4_generative_relations_mcda.3/#generative-relations-mcda","text":"In this workshop, we will learn how enable agents to utilize MCDA (Multi Criteria Decision Analyses) in their spatial behaviors.","title":"Generative Relations: MCDA"},{"location":"notebooks/w4_generative_relations_mcda.3/#0-initialization","text":"","title":"0. Initialization"},{"location":"notebooks/w4_generative_relations_mcda.3/#01-load-required-libraries","text":"import os import matplotlib as mpl import matplotlib.pyplot as plt from matplotlib import cm import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx import pandas as pd import scipy as sp np . random . seed ( 0 ) # extra import function def lattice_from_csv ( file_path ): # read metadata meta_df = pd . read_csv ( file_path , nrows = 3 ) shape = np . array ( meta_df [ 'shape' ]) unit = np . array ( meta_df [ 'unit' ]) minbound = np . array ( meta_df [ 'minbound' ]) # read lattice lattice_df = pd . read_csv ( file_path , skiprows = 5 ) # create the buffer buffer = np . array ( lattice_df [ 'value' ]) . reshape ( shape ) # create the lattice l = tg . to_lattice ( buffer , minbound = minbound , unit = unit ) return l","title":"0.1. Load required libraries"},{"location":"notebooks/w4_generative_relations_mcda.3/#02-define-the-neighborhood-stencil","text":"# creating neighborhood definition stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the center to zero stencil . set_index ([ 0 , 0 , 0 ], 0 )","title":"0.2. Define the Neighborhood (Stencil)"},{"location":"notebooks/w4_generative_relations_mcda.3/#03-load-the-envelope-lattice-as-the-avialbility-lattice","text":"# loading the lattice from csv lattice_path = os . path . relpath ( '../data/voxelated_model_3_6.csv' ) avail_lattice = lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice )","title":"0.3. Load the envelope lattice as the avialbility lattice"},{"location":"notebooks/w4_generative_relations_mcda.3/#04-load-agents-information","text":"# loading program (agents information) from CSV prgm_path = os . path . relpath ( '../data/Matrix9.csv' ) agn_info = np . genfromtxt ( prgm_path , delimiter = ',' )[ 1 :, 1 :] agn_ids = agn_info [:, 0 ] # extract agent ids agn_ids = agn_info [:, 0 ] # extract agent preferences agn_prefs = agn_info [:, 1 : 27 ] # extract agent space area agn_space_area = agn_info [:, 27 ] # extract the initial location agn_initial_loc = agn_info [:, 28 ] . astype ( int ) #print(agn_prefs.shape) #print(agn_ids_space) #print(agn_ids_entrance) #print(agn_prefs) #print(agn_initial_loc) agn_data = pd . read_csv ( prgm_path ) agn_data . loc [ 1 ][ \"sun_access\" ] 1.0 agn_data . loc [ 0 ] space_name Atrium space_id 0 Atrium 1 Courtyard 1 Starter_housing 0 Assisted_living 0 Student_housing 0 Supermarket 0.2 Cafe_restaurant_pub 0.2 Cinema 0.2 Arcade 0.2 Workshops 0.2 Community_center 0 Co_cooking_center 0 Library 0.2 Gym 0 Laundry_room 0 Ent_access_courtyard 0 Ent_access_trashroom 0 Ent_access_parking 0 Ent_access_supermarket 0 Ent_access_library 0 Ent_access_cinema_cafe_arcade 0 Ent_access_atrium 1 sun_access 1 sky_view 0 silent_level_active 0.6 noise_sensitivity 0 space_area 188 initial_loc -1 0 floor 1 1 floor 0 Name: 0, dtype: object","title":"0.4. Load Agents Information"},{"location":"notebooks/w4_generative_relations_mcda.3/#05-initialize-environment-information-layers-from-sun-access-lattice-sky-view-lattice-noise-lattice","text":"# loading the lattice from csv sun_acc_path = os . path . relpath ( '../data/solar_access_3_6.csv' ) sun_acc_lattice = lattice_from_csv ( sun_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info_dict = { \"sun_access\" : sun_acc_lattice , #\"test_layer\": test_latice } env_info = [ sun_acc_lattice ] # loading the lattice from csv skyview_acc_path = os . path . relpath ( '../data/skyview_3_6.csv' ) skyview_acc_lattice = lattice_from_csv ( sun_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info_dict = { \"sky_view\" : skyview_acc_lattice , #\"test_layer\": test_latice } env_info = [ skyview_acc_lattice ] # loading the lattice from csv external_noise_acc_path = os . path . relpath ( '../data/sound_3_6.csv' ) external_noise_acc_lattice = lattice_from_csv ( sun_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info_dict = { \"noise_sensitivity \" : external_noise_acc_lattice , #\"test_layer\": test_latice } env_info = [ external_noise_acc_lattice ]","title":"0.5. Initialize environment information layers from Sun Access Lattice, Sky View Lattice, Noise Lattice,"},{"location":"notebooks/w4_generative_relations_mcda.3/#1-abm-simulation","text":"","title":"1. ABM Simulation"},{"location":"notebooks/w4_generative_relations_mcda.3/#11-initialize-the-agents","text":"# initialize the occupation lattice occ_lattice = avail_lattice * 0 - 1 # Finding the index of the available voxels in avail_lattice avail_flat = avail_lattice . flatten () avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # count the number of spaces (rows) and intiialize an agent for each space agn_num = len ( agn_info ) # choose the initial location of agents randomly select_id = np . random . choice ( len ( avail_index ), agn_num , replace = False ) agn_origins = avail_index [ select_id ] # adding the origins to the agents locations agn_locs = [] # for each agent origin ... for a_id , a_origin , a_init_loc in zip ( agn_ids , agn_origins , agn_initial_loc ): if a_init_loc == - 1 : final_a_origin = a_origin else : final_a_origin = np . unravel_index ( a_init_loc , avail_lattice . shape ) # add the origin to the list of agent locations agn_locs . append ([ final_a_origin ]) # set the origin in availablity lattice as 0 (UNavailable) avail_lattice [ tuple ( final_a_origin )] = 0 # set the origin in occupation lattice as the agent id (a_id) occ_lattice [ tuple ( final_a_origin )] = int ( a_id ) # this is now based on the id of the agent in the program print ( select_id ) print ( init_avail_lattice . sum ()) print ( avail_lattice . sum ()) print ( a_id ) [1817 5286 7331 6136 7187 6638 4502 5686 2232 451 7436 356 5768 2635 162 6249 4995 1422 6328 878 6190 7138] 7864 7842 24.0 def floor_level_lattice ( target_floor , avail_lattice ): # initialize the floor lattice floor_lattice = avail_lattice * 0.0 # cut a single column out single_column = floor_lattice [ 0 , 0 ,:] # specify a range array based on the number of voxels in th ecolumn range_column = np . arange ( single_column . size ) # compute the distances based on the range column distance_column = ( 1 / ( np . abs ( range_column - target_floor ) + 1 ) ** 2 ) . reshape ( 1 , 1 , avail_lattice . shape [ 2 ]) # compute the floor lattice floor_lattice += distance_column # return the floor lattice return floor_lattice ground_floor_lattice = floor_level_lattice ( 0 , avail_lattice ) first_floor_lattice = floor_level_lattice ( 1 , avail_lattice ) env_info_dict [ \"0 floor\" ] = ground_floor_lattice env_info_dict [ \"1 floor\" ] = first_floor_lattice # visualizing the info lattices p = pv . Plotter ( notebook = True ) info_val_list = list ( env_info_dict . values ()) info_key_list = env_info_dict . keys () for i , k in enumerate ( info_key_list ): print ( i , k ) base_lattice = info_val_list [ 0 ] # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions: shape because we want to inject our values grid . dimensions = base_lattice . shape # The bottom left corner of the data set grid . origin = base_lattice . minbound # These are the cell sizes along each axis grid . spacing = base_lattice . unit def create_mesh ( value ): f = int ( value ) lattice = info_val_list [ f ] # Add the data values to the cell data grid . point_arrays [ \"info\" ] = lattice . flatten ( order = \"F\" ) # Flatten the Lattice # adding the volume opacity = np . array ([ 0 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 ]) * 1.5 p . add_volume ( grid , cmap = \"coolwarm\" , name = 'sphere' , clim = [ 0.0 , 1.0 ], opacity = opacity , shade = True ) return p . add_slider_widget ( create_mesh , [ 0 , len ( info_val_list ) - 1 ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) 0 noise_sensitivity 1 0 floor 2 1 floor var element = $('#6b52fea4-2676-4f6e-bb77-afa62cf4a057'); {\"model_id\": \"3354754db3a445fc96188cb2edc04b73\", \"version_major\": 2, \"version_minor\": 0} [(246.73679328932968, 145.93679328932967, 225.13679328932966), (48.60000000000001, -52.2, 27.0), (0.0, 0.0, 1.0)] def dynamic_noise_lattice ( agn_locs , avail_lattice ): # define the noise range noise_range = [ 10.0 , 60.0 ] # initialize noise sources noise_src_points = [] noise_src_levels = [] # iterate over agents for a_id in range ( len ( agn_locs )): # extract agent locations a_locs = agn_locs [ a_id ] # retrieve the silent level of the agent a_noise_level_mapped = 1 - agn_data . loc [ a_id ][ \"silent_level_active\" ] # mapping the [0,1] values to noise level (db) a_noise_level = a_noise_level_mapped * ( noise_range [ 1 ] - noise_range [ 0 ]) + noise_range [ 0 ] # for each agent location for a_loc in a_locs : # append the noise source information noise_src_points . append ( a_loc ) noise_src_levels . append ( a_noise_level ) # convert to numpy array noise_src_points = np . array ( noise_src_points ) # create full lattice full_lattice = avail_lattice * 0 + 1 # extract the coordiantes of the centroid of all voxel vox_centroids = full_lattice . centroids # extract voxel indices of all voxels vox_indices = np . array ( np . where ( full_lattice == 1 )) . T # initializing the sum lattice of noise sum_noise_lats = avail_lattice * 0.0 # for each source of noise for src_point , src_level in zip ( noise_src_points , noise_src_levels ): # initialize the occupation lattice dist_latice = avail_lattice * 0.0 for cen , ind in zip ( vox_centroids , vox_indices ): # compute the euclidian distance dist_latice [ tuple ( ind )] = sp . spatial . distance . euclidean ( cen , src_point ) # computing the noise lattice from dist lattice noise_latice = src_level - 20 * np . log10 ( dist_latice ) - 8 # summing sum_noise_lats += np . power ( 10 , noise_latice / 10.0 ) # computing the final aggregation agg_noise_lats = 10 * np . log10 ( sum_noise_lats ) # normalizing the noise values normalized_silence_lattice = 1 - ( agg_noise_lats - np . min ( agg_noise_lats )) / ( np . max ( agg_noise_lats ) - np . min ( agg_noise_lats )) return normalized_silence_lattice","title":"1.1. Initialize the Agents"},{"location":"notebooks/w4_generative_relations_mcda.3/#12-running-the-simulation","text":"# floor_info = {\"0 floor\" and \"1 floor\" : floor_level_lattice, dynamic_info = { \"noise_sensitivity \" : dynamic_noise_lattice , } # make a deep copy of occupation lattice cur_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # initialzing the list of frames frames = [ cur_occ_lattice ] # setting the time variable to 0 t = 0 n_frames = max ( agn_space_area ) # Simulation Loop # main feedback loop of the simulation (for each time step ...) while t < n_frames : # update the info lattices # iterate over dynamic lattices for info_key , info_function in dynamic_info . items (): env_info_dict [ info_key ] = info_function ( agn_locs , avail_lattice ) # env_info_dict[\"noise_sensitivity \"] = dynamic_noise_lattice(agn_locs, avail_lattice) # Agent Loop # for each agent ... for a_id in range ( agn_num ): # retrieve the list of the locations of the current agent a_locs = agn_locs [ a_id ] # Make sure there are no more voxels than specified (area check) if len ( a_locs ) < agn_data . loc [ a_id ][ \"space_area\" ]: # agn_space_area[a_id]: # initialize the list of free neighbours free_neighs = [] # Location loop # for each location of the agent for loc in a_locs : # retrieve the list of neighbours of the agent based on the stencil neighs = avail_lattice . find_neighbours_masked ( stencil , loc = loc ) # for each neighbour ... for n in neighs : # compute 3D index of neighbour neigh_3d_id = np . unravel_index ( n , avail_lattice . shape ) # if the neighbour is available... if avail_lattice [ neigh_3d_id ]: # add the neighbour to the list of free neighbours free_neighs . append ( neigh_3d_id ) # check if found any free neighbour if len ( free_neighs ) > 0 : # convert free neighbours to a numpy array free_neighs = np . array ( free_neighs ) # retrieving the entrance access value of the free neighbours neigh_vals = [] # retrieve agent preferences a_pref = agn_prefs [ a_id ] a_pref_dict = agn_data . loc [ a_id ] . to_dict () # Neighbour Evaluation Loop for neigh in free_neighs : neigh_value = 1.0 # for every lattice in the environment informations for info_key , info_lattice in env_info_dict . items (): # Here we utilise Fuzzy Logics to be able to compare different layers # of environmental information and evaluate the voxel for the agent. # This method is introduced, and generalised in Pirouz Nourian dissertation: # section 5.7.3, pp. 201-208, eq. 57. You can refer to this section for # comprehensive mathematical details. vox_val = info_lattice [ tuple ( neigh )] agn_vox_val = np . power ( vox_val , a_pref_dict [ info_key ]) neigh_value *= agn_vox_val # add the neighbour value to the list of values neigh_vals . append ( neigh_value ) # convert to numpy array neigh_vals = np . array ( neigh_vals ) # select the neighbour with highest value selected_int = np . argmax ( neigh_vals ) # find 3D intiger index of selected neighbour selected_neigh_3d_id = tuple ( free_neighs [ selected_int ] . T ) # find the location of the newly selected neighbour selected_neigh_loc = np . array ( selected_neigh_3d_id ) . flatten () # add the newly selected neighbour location to agent locations agn_locs [ a_id ] . append ( selected_neigh_loc ) # set the newly selected neighbour as UNavailable (0) in the availability lattice avail_lattice [ selected_neigh_3d_id ] = 0 # set the newly selected neighbour as OCCUPIED by current agent # (-1 means not-occupied so a_id) occ_lattice [ selected_neigh_3d_id ] = a_id # constructing the new lattice new_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # adding the new lattice to the list of frames frames . append ( new_occ_lattice ) # adding one to the time counter t += 1","title":"1.2. Running the Simulation"},{"location":"notebooks/w4_generative_relations_mcda.3/#13-visualizing-the-simulation","text":"p = pv . Plotter ( notebook = True ) base_lattice = frames [ 0 ] # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) #Make a dictonary for the annotations space_list = { 0 : \"Atrium\" , 1 : \"Courtyard\" , 2 : \"Starter housing\" , 3 : \"Assisted living\" , 4 : \"Student housing\" , 5 : \"Supermarket\" , 6 : \"Cafe restaurant pub\" , 7 : \"Cinema\" , 8 : \"Arcade\" , 9 : \"Workshops\" , 10 : \"Community center\" , 11 : \"Co cooking center\" , 12 : \"Library\" , 13 : \"Gym\" , 14 : \"Laundry room\" , 15 : \"Green_roof\" , 16 : \"Entrance courtyard\" , 17 : \"Entrance trashroom\" , 18 : \"Entrance parking\" , 19 : \"Entrance supermarket\" , 20 : \"Entrance library\" , 21 : \"Entrance cinema cafe arcade\" , 22 : \"Entrance atrium\" , } #make a dictionary for sargs = dict ( shadow = True , n_labels = 0 , italic = False , fmt = \" %.0f \" , font_family = \"arial\" , height = 0.6 , vertical = True , position_x = 1.05 , position_y = 1 ) def create_mesh ( value ): f = int ( value ) lattice = frames [ f ] # Add the data values to the cell data grid . cell_arrays [ \"Agents\" ] = lattice . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , agn_num - 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = True , annotations = space_list , scalar_bar_args = sargs , cmap = \"tab20b\" ) return p . add_slider_widget ( create_mesh , [ 0 , n_frames ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.2 ), pointb = ( 0.9 , 0.2 )) p . show ( use_ipyvtk = True ) var element = $('#b2061e6f-f795-4b0b-bfd5-0f97aee1d9c8'); {\"model_id\": \"c70cb8a06abe43358186a578e15e3a14\", \"version_major\": 2, \"version_minor\": 0} [(253.02459757597026, 152.2245973852354, 231.42459588319835), (48.60000133514404, -52.19999885559082, 26.99999964237213), (0.0, 0.0, 1.0)]","title":"1.3. Visualizing the simulation"},{"location":"notebooks/w4_generative_relations_mcda.3/#23-saving-lattice-frames-in-csv","text":"for i , lattice in enumerate ( frames ): csv_path = os . path . relpath ( '../data/abm_mcda/abm_f_' + f ' { i : 03 } ' + '.csv' ) lattice . to_csv ( csv_path )","title":"2.3. Saving lattice frames in CSV"},{"location":"notebooks/w4_generative_relations_mcda.3/#credits","text":"__author__ = \"Shervin Azadi and Pirouz Nourian\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/spatial_computing_workshops\" __summary__ = \"Spatial Computing Design Studio Workshop on MCDA and Path Finding for Generative Spatial Relations\"","title":"Credits"}]}