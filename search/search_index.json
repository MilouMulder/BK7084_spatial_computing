{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spatial Computing Project Template This is a project template for Spatial Computing Students. Students shall fork this repository and use it as the basis of their project. Mid-term and Final submission is expected through pull GitHub. This web portal is the result of the course BK7083 \u2018\u2019Computational Design Studio\u2019\u2019 given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. During this minor, we have formulated a program of requirements and subsequently used mathematical spatial computing constructs to design and simulate the optimum building. The assignment of this course consists of a computational design for the site in the area of the Rotterdamse Maakkwartier. Currently, this building (also known as ZOHO) is used for residency, workshops, studios and startups. This is why the ZOHO is promoted with the following: For and by makers in design, art, culture, media, tech, food, architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves, ZOHO, and the city in an innovative way. (bron: Stichting ZOHOCITIZENS Ondernemerscollectief. (2018, 6 april). Wat is ZOHO. Geraadpleegd op 10 december 2020, van https://zohorotterdam.nl/over-zoho/) The aim of this project is to design a new building that fits into the requirements given by the tutors, the (imaginary) future residents and ourselves, using diverse python scripts. The structure of this webpage is based on the assignments of the weeks, where each week has its own folder. These folders are divided into two extra folders: \u2018Process\u2019 and \u2018Products\u2019. In the folders \u2018Process\u2019 the research, which was needed for the final products and conclusions, is documented. The conclusions can therefore be found in the folder \u2018Products\u2019.","title":"Home"},{"location":"#spatial-computing-project-template","text":"This is a project template for Spatial Computing Students. Students shall fork this repository and use it as the basis of their project. Mid-term and Final submission is expected through pull GitHub. This web portal is the result of the course BK7083 \u2018\u2019Computational Design Studio\u2019\u2019 given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. During this minor, we have formulated a program of requirements and subsequently used mathematical spatial computing constructs to design and simulate the optimum building. The assignment of this course consists of a computational design for the site in the area of the Rotterdamse Maakkwartier. Currently, this building (also known as ZOHO) is used for residency, workshops, studios and startups. This is why the ZOHO is promoted with the following: For and by makers in design, art, culture, media, tech, food, architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves, ZOHO, and the city in an innovative way. (bron: Stichting ZOHOCITIZENS Ondernemerscollectief. (2018, 6 april). Wat is ZOHO. Geraadpleegd op 10 december 2020, van https://zohorotterdam.nl/over-zoho/) The aim of this project is to design a new building that fits into the requirements given by the tutors, the (imaginary) future residents and ourselves, using diverse python scripts. The structure of this webpage is based on the assignments of the weeks, where each week has its own folder. These folders are divided into two extra folders: \u2018Process\u2019 and \u2018Products\u2019. In the folders \u2018Process\u2019 the research, which was needed for the final products and conclusions, is documented. The conclusions can therefore be found in the folder \u2018Products\u2019.","title":"Spatial Computing Project Template"},{"location":"a1.1_Process/","text":"Design philosophy To substantiate our design decisions, we formulated our own Design Philosophy containing the design goals, key performances and a vision about the future residents. Furthermore, this design philosophy includes the vision of how the building will fit in and what it will add to its environment. Design goals The given Design goals are separated into two categories: quantitative and qualitative (see Figure X ). Additional we formulated three more design goals which have priority: Optimise the building for Sunlight and Sound Pollution: With the possibilities that come along with the different python scripts, our aim is it to design a building that is optimised on the aspects of sunlight and sound pollution. This is not only important for the functions that will be found in the future building, but also for its environment. Based on the calculations, we e.g. will shape an envelope that blocks the sun for the surrounded buildings minimally. Develop a layout that suits the residents: Every target group has its own needs. These needs can not only be translated into the desirable view or avoiding noise disturbance, but it can also be translated into the design of the floor plans and the connections between different spaces. The elderly, for example, are in a different phase of their life than students. Students probably will need a bigger bedroom so they will have enough space to study. Therefore, elderly people will only sleep in their bedroom but will spend more time in their living room, so in this case, a bigger living room is preferred. With these kinds of guidelines, we will create a suitable residence for our residents. Create a pleasant Living Environment: We want to see our future residents happy. Happy residents will become happy and friendly neighbours which will lead to a pleasant living environment, an environment that feels like home , and not only a homey residence. We want to provoke this by creating spaces where the residents can interact with each other (like a co-cooking center or a community center). Furthermore, a healthy amount of daylight and greenery will increase the living quality. Add possibilities to the Rotterdamse Maakkwartier: The current building contains not only residences, it is also filled with diverse workshop-rooms, studios and small startups. This great and strong principle is very important to the neighbourhood and therefore should be preserved in the new building. Additionally to this, diverse public functions will be added creating a building that will be a cooperative live-work-playassociation, accessible for residents and other citizens. Figure X: Given design goals Future residents The shortage of residency in today\u2019s society is an important issue that affects a variety of citizens and therefore it has to be addressed. Due to the significance of this problem, the project will offer housing where people of different life stages can live together. Starters, students and people with the need for assisted living will form a residential community which can lead to beautiful interactions. Especially during the current pandemic, we see how much we depend on each other: for example, it is not safe for the elderly to do groceries, so it would be great if neighbours (in our case starters of students) could do some groceries for them. Additionally, the connection between the target groups will be supported by different design decisions, such as the possibilities to cook together or for each other in the co-cooking center, do workshops together or meet each other in the community center. add image Key Performance add text Analysis on the Site Before we begin the computational design of the new building, it is important to investigate the current state of our site and its environment. Therefore we did research on different aspects that we thought were important to take into account for the new building. Building visualisation The visualization of the surrounding environment of our site ( Figure X ) consists of a scale of architectural styles. This is due to the different building years, which have led to a diverse neighbourhood where different facades are positioned next to each other. The functions of the buildings also play a role in the diverse visualization. The main function is dwelling but there are also businesses and offices situated. Furthermore, our site is in ZOHO, which is the name of the area of the Rotterdamse Maakkwartier. A developing working and living space for and by makers in design, art, culture, media, tech, food architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves and ZOHO. This is reflected in the appearance of the environment. Creative and notable graphs can be found on the walls, which gives the area a coming up and hip neighbourhood feel. Moreover, near the site there is a shared garden and sportsfield for residents to use and where they can meet others. After analyzing the environment it is clear that the current building ( Figure X ) blends right in the area. Different kinds of functions that cause multiple identities. The building is a combination of a variation of heights and both monotone and trendy patterned facades. Figure X: Building visualisation Access routes In Figure X the accessibility of our site is shown. Our site is directly surrounded by a sidewalk with a few thresholds for access to the parking garage. Only the northeast side of the building is more focused on the accessibility for cars, because of the direct street that is situated opposite the building. Near the building, there are some car parking and a few bicycle parking. Furthermore, the main roads for vehicles that surround our site are bicycle roads (a bicycle road where cars are the guests and cyclists have the priority) and \u2018normal\u2019 car roads. In Figure X it is visualized which car roads are busy and which are widely used. In addition to this, the green walking route that is close to our site is shown. Figure X: Access routes to the site Building heights in the environment If you look at the built environment, as shown in Figure X , and start in the north/ northeast, you can see that these buildings are mainly between 18 and 23 meters high. Most of these buildings are terraced houses. If you go around the map clockwise, the buildings are getting higher. Here we still have residents' buildings, but now shaped as duplex houses. At the bottom of the map (south), we are getting closer to the center of Rotterdam. This is why the buildings in the Southwest are higher than the buildings in the north: These are mainly office buildings with a height between 40 meters or even higher than 100 meters. To finish the clock, in the West, same as in the Southeast, we can find duplex houses. Nevertheless, these buildings have more storeys. With a height of 22 meters, our site currently fits in the street scene very well due to the similar building heights. But if the future building is higher than 40 meters, it will become more of a landmark.. Figure X: Building heights in the environment Program of requirements Additionally to the Design Philosophy, we formulated a program of requirements. This does not only include spatial requirements like the square meter or the ideal storey and the functional requirements like the number of bathrooms or storage space that is needed, it also contains important information about the noise. Functions size In Figure X , a table is shown where aspects concerning the sizes of all the spaces can be found: The floor height, on which storey, square meter, amount of rooms, amount of voxels and for how many people the space is designed. This information will be used to construct the building in spatial computing. Figure X: Sizes of the functions Functional requirements add text add table Noise table The average assigned noise level per space can be seen in Figure X . As well as the hours in which the noise levels occur. The corresponding reason for the chosen time in which the noise levels score a middle to high level has also been added. Besides, the spaces that are noise sensitive have also been classified. Figure X: Noise table Noise chart The previous table showed us the average noise level and sensitivity of the various rooms. To have a better impression when the functions reach the different noise levels in specific moments of the day, the following noise-diagram is made. This gives us a good overview of which functions can be located next to each other, and which ones have to be separated by a greater distance. Figure X: Noise chart","title":"Process"},{"location":"a1.1_Process/#design-philosophy","text":"To substantiate our design decisions, we formulated our own Design Philosophy containing the design goals, key performances and a vision about the future residents. Furthermore, this design philosophy includes the vision of how the building will fit in and what it will add to its environment.","title":"Design philosophy"},{"location":"a1.1_Process/#design-goals","text":"The given Design goals are separated into two categories: quantitative and qualitative (see Figure X ). Additional we formulated three more design goals which have priority: Optimise the building for Sunlight and Sound Pollution: With the possibilities that come along with the different python scripts, our aim is it to design a building that is optimised on the aspects of sunlight and sound pollution. This is not only important for the functions that will be found in the future building, but also for its environment. Based on the calculations, we e.g. will shape an envelope that blocks the sun for the surrounded buildings minimally. Develop a layout that suits the residents: Every target group has its own needs. These needs can not only be translated into the desirable view or avoiding noise disturbance, but it can also be translated into the design of the floor plans and the connections between different spaces. The elderly, for example, are in a different phase of their life than students. Students probably will need a bigger bedroom so they will have enough space to study. Therefore, elderly people will only sleep in their bedroom but will spend more time in their living room, so in this case, a bigger living room is preferred. With these kinds of guidelines, we will create a suitable residence for our residents. Create a pleasant Living Environment: We want to see our future residents happy. Happy residents will become happy and friendly neighbours which will lead to a pleasant living environment, an environment that feels like home , and not only a homey residence. We want to provoke this by creating spaces where the residents can interact with each other (like a co-cooking center or a community center). Furthermore, a healthy amount of daylight and greenery will increase the living quality. Add possibilities to the Rotterdamse Maakkwartier: The current building contains not only residences, it is also filled with diverse workshop-rooms, studios and small startups. This great and strong principle is very important to the neighbourhood and therefore should be preserved in the new building. Additionally to this, diverse public functions will be added creating a building that will be a cooperative live-work-playassociation, accessible for residents and other citizens. Figure X: Given design goals","title":"Design goals"},{"location":"a1.1_Process/#future-residents","text":"The shortage of residency in today\u2019s society is an important issue that affects a variety of citizens and therefore it has to be addressed. Due to the significance of this problem, the project will offer housing where people of different life stages can live together. Starters, students and people with the need for assisted living will form a residential community which can lead to beautiful interactions. Especially during the current pandemic, we see how much we depend on each other: for example, it is not safe for the elderly to do groceries, so it would be great if neighbours (in our case starters of students) could do some groceries for them. Additionally, the connection between the target groups will be supported by different design decisions, such as the possibilities to cook together or for each other in the co-cooking center, do workshops together or meet each other in the community center. add image","title":"Future residents"},{"location":"a1.1_Process/#key-performance","text":"add text","title":"Key Performance"},{"location":"a1.1_Process/#analysis-on-the-site","text":"Before we begin the computational design of the new building, it is important to investigate the current state of our site and its environment. Therefore we did research on different aspects that we thought were important to take into account for the new building.","title":"Analysis on the Site"},{"location":"a1.1_Process/#building-visualisation","text":"The visualization of the surrounding environment of our site ( Figure X ) consists of a scale of architectural styles. This is due to the different building years, which have led to a diverse neighbourhood where different facades are positioned next to each other. The functions of the buildings also play a role in the diverse visualization. The main function is dwelling but there are also businesses and offices situated. Furthermore, our site is in ZOHO, which is the name of the area of the Rotterdamse Maakkwartier. A developing working and living space for and by makers in design, art, culture, media, tech, food architecture and urban planning. All pioneers who want to use their craftsmanship to strengthen themselves and ZOHO. This is reflected in the appearance of the environment. Creative and notable graphs can be found on the walls, which gives the area a coming up and hip neighbourhood feel. Moreover, near the site there is a shared garden and sportsfield for residents to use and where they can meet others. After analyzing the environment it is clear that the current building ( Figure X ) blends right in the area. Different kinds of functions that cause multiple identities. The building is a combination of a variation of heights and both monotone and trendy patterned facades. Figure X: Building visualisation","title":"Building visualisation"},{"location":"a1.1_Process/#access-routes","text":"In Figure X the accessibility of our site is shown. Our site is directly surrounded by a sidewalk with a few thresholds for access to the parking garage. Only the northeast side of the building is more focused on the accessibility for cars, because of the direct street that is situated opposite the building. Near the building, there are some car parking and a few bicycle parking. Furthermore, the main roads for vehicles that surround our site are bicycle roads (a bicycle road where cars are the guests and cyclists have the priority) and \u2018normal\u2019 car roads. In Figure X it is visualized which car roads are busy and which are widely used. In addition to this, the green walking route that is close to our site is shown. Figure X: Access routes to the site","title":"Access routes"},{"location":"a1.1_Process/#building-heights-in-the-environment","text":"If you look at the built environment, as shown in Figure X , and start in the north/ northeast, you can see that these buildings are mainly between 18 and 23 meters high. Most of these buildings are terraced houses. If you go around the map clockwise, the buildings are getting higher. Here we still have residents' buildings, but now shaped as duplex houses. At the bottom of the map (south), we are getting closer to the center of Rotterdam. This is why the buildings in the Southwest are higher than the buildings in the north: These are mainly office buildings with a height between 40 meters or even higher than 100 meters. To finish the clock, in the West, same as in the Southeast, we can find duplex houses. Nevertheless, these buildings have more storeys. With a height of 22 meters, our site currently fits in the street scene very well due to the similar building heights. But if the future building is higher than 40 meters, it will become more of a landmark.. Figure X: Building heights in the environment","title":"Building heights in the environment"},{"location":"a1.1_Process/#program-of-requirements","text":"Additionally to the Design Philosophy, we formulated a program of requirements. This does not only include spatial requirements like the square meter or the ideal storey and the functional requirements like the number of bathrooms or storage space that is needed, it also contains important information about the noise.","title":"Program of requirements"},{"location":"a1.1_Process/#functions-size","text":"In Figure X , a table is shown where aspects concerning the sizes of all the spaces can be found: The floor height, on which storey, square meter, amount of rooms, amount of voxels and for how many people the space is designed. This information will be used to construct the building in spatial computing. Figure X: Sizes of the functions","title":"Functions size"},{"location":"a1.1_Process/#functional-requirements","text":"add text add table","title":"Functional requirements"},{"location":"a1.1_Process/#noise-table","text":"The average assigned noise level per space can be seen in Figure X . As well as the hours in which the noise levels occur. The corresponding reason for the chosen time in which the noise levels score a middle to high level has also been added. Besides, the spaces that are noise sensitive have also been classified. Figure X: Noise table","title":"Noise table"},{"location":"a1.1_Process/#noise-chart","text":"The previous table showed us the average noise level and sensitivity of the various rooms. To have a better impression when the functions reach the different noise levels in specific moments of the day, the following noise-diagram is made. This gives us a good overview of which functions can be located next to each other, and which ones have to be separated by a greater distance. Figure X: Noise chart","title":"Noise chart"},{"location":"a1.1_Product/","text":"Flowchart add text add image Bubble diagram The bubble diagram in Figure X consists of four types of spaces: housing, centre, facilities and recreation. While the centre for public visitors is the atrium, in which all public spaces eventually lead to, the centre for the residents is the courtyard, this is where all the spaces that are only meant for residents are connected to. During the making of the bubble diagram, noise pollution is taken into account. The spaces that have been put on the left produce noise pollution and on the right side are noise sensitive functions. Furthermore, for the placement of the entrances the visuality, accessibility, and convenience have been considered. Figure X: Bubble Diagram Metronetwork The Metro network in Figure X shows examples of the movement through the building of various residents. This graph gives us a first observation of how the connections in our bubble diagram could be used. Figure X: Metronetwerk Resident stories To represent the future residents, we made up six imaginary stories: two students, two starters and two elderly. Based on these people we tried to optimize our Metro Network. Figure X: Resident stories Matrix The matrix shows different kinds of abstract information which later will be used in the spatial computation of our site. The first part represents the connection between the different functions. As you can see, the matrix is not mirrored, this is due to a different kind of importance between the voxels. For example, is the connection between assisted living and starter housing more important (because the starters could help the residents of the assisted livings with small things) than the connection between starter housing and assisted living. In addition to the accessibility between the voxels, we added factors of graph-distance (like accessibility to the entrances and greenery), factors belonging to the euclidean-distance (silent level and noise sensitivity), and elements which can be categorized as \u2018visibility\u2019 such as daylight, direct sunlight and view. Figure X: Matrix","title":"Products"},{"location":"a1.1_Product/#flowchart","text":"add text add image","title":"Flowchart"},{"location":"a1.1_Product/#bubble-diagram","text":"The bubble diagram in Figure X consists of four types of spaces: housing, centre, facilities and recreation. While the centre for public visitors is the atrium, in which all public spaces eventually lead to, the centre for the residents is the courtyard, this is where all the spaces that are only meant for residents are connected to. During the making of the bubble diagram, noise pollution is taken into account. The spaces that have been put on the left produce noise pollution and on the right side are noise sensitive functions. Furthermore, for the placement of the entrances the visuality, accessibility, and convenience have been considered. Figure X: Bubble Diagram","title":"Bubble diagram"},{"location":"a1.1_Product/#metronetwork","text":"The Metro network in Figure X shows examples of the movement through the building of various residents. This graph gives us a first observation of how the connections in our bubble diagram could be used. Figure X: Metronetwerk","title":"Metronetwork"},{"location":"a1.1_Product/#resident-stories","text":"To represent the future residents, we made up six imaginary stories: two students, two starters and two elderly. Based on these people we tried to optimize our Metro Network. Figure X: Resident stories","title":"Resident stories"},{"location":"a1.1_Product/#matrix","text":"The matrix shows different kinds of abstract information which later will be used in the spatial computation of our site. The first part represents the connection between the different functions. As you can see, the matrix is not mirrored, this is due to a different kind of importance between the voxels. For example, is the connection between assisted living and starter housing more important (because the starters could help the residents of the assisted livings with small things) than the connection between starter housing and assisted living. In addition to the accessibility between the voxels, we added factors of graph-distance (like accessibility to the entrances and greenery), factors belonging to the euclidean-distance (silent level and noise sensitivity), and elements which can be categorized as \u2018visibility\u2019 such as daylight, direct sunlight and view. Figure X: Matrix","title":"Matrix"},{"location":"a1_planning/","text":"Planning Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning"},{"location":"a1_planning/#planning","text":"Here you should include the process and product of your 1st activity: Planning Title Planning (process): Programme of Requirements & Network (product) Objective Formulate the design problems, form a programme of requirements, form a network, formulate your design principles and the idea (spatial sequences/experience/stories visible in a network). Procedure Describe the hierarchy of design decisions, formulate design goals, define design principles, identify stages in the design process that could be supported by algorithms, draw a flowchart to reflect on these steps and their connections and update it every week. Develop a programme of requirements, an idea (encapsulating the added value of the building and what is going to be unique about it in terms of human experiences) and a corresponding network indicating the main trips inside the building to be facilitated by direct connections matching with the scenarios envisaged in the idea. Formulate the design principles indicating what is a good shape for the building given operational, climatic, or structural aspects.","title":"Planning"},{"location":"a2.1_Process/","text":"Voxel size - decision making Flowchart: Voxels","title":"Process"},{"location":"a2.1_Process/#voxel-size-decision-making","text":"","title":"Voxel size - decision making"},{"location":"a2.1_Process/#flowchart-voxels","text":"","title":"Flowchart: Voxels"},{"location":"a2.1_Product/","text":"Notebook w1: Voxelization Voxel amount for each function Kangeroo","title":"Products"},{"location":"a2.1_Product/#notebook-w1-voxelization","text":"","title":"Notebook w1: Voxelization"},{"location":"a2.1_Product/#voxel-amount-for-each-function","text":"","title":"Voxel amount for each function"},{"location":"a2.1_Product/#kangeroo","text":"","title":"Kangeroo"},{"location":"a2_configuring/","text":"Configuring Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring"},{"location":"a2_configuring/#configuring","text":"Here you should include the process and product of your 2nd activity: Configuring Title Configuring (process): Circulation Manifold (product) Objective Formulate a spatial (topological) concept, design a modular circulation manifold on a pixel/voxel grid. Procedure Construct a voxelated model of the site with a maximum height of 100 meters. Orient the voxel grid to a global coordinate system (e.g. geographical North-East-West-South). Size the voxels carefully based on the modular height of steps and the length of stair flights and ramps so that they fit in X/Y directions into multiple pixels. Choose the Z size of voxels according to step risers and choose the same size for X and Y as a whole multiple of step threads. There are three types of spaces in terms of pedestrian movement in buildings, metaphorically speaking, spaces to walk through (e.g. corridors, ramps, and stairs), spaces to stand on (e.g. platforms connecting doors to corridors and stairs) and spaces to sit on (functional rooms/spaces). Construct a simplified mesh model of all bridges (corridors, ramps, stairs) connected by standing platforms in a modular grid of voxels/pixels. Take into account the free-height necessary for all spaces and pack them into the bounding volume of the building. For every functional space, leave a single pixel as a standing platform and colour it with the corresponding colour.","title":"Configuring"},{"location":"a3.1_Process/","text":"Sun analysis (year basis) Before running the Solar Envelope we researched how the surrounding buildings cast a shadow on the current site throughout the year. Here for the analysis ran every 15th day of the month at 12:00 o\u2019clock. This research shows us that if we would not increase the height of the building, it will only cast a shadow on the lower part of the building across the street (northeast) in the winter months. [3_zonanalyse.png] Flowchart: Solar Envelope","title":"Process"},{"location":"a3.1_Process/#sun-analysis-year-basis","text":"Before running the Solar Envelope we researched how the surrounding buildings cast a shadow on the current site throughout the year. Here for the analysis ran every 15th day of the month at 12:00 o\u2019clock. This research shows us that if we would not increase the height of the building, it will only cast a shadow on the lower part of the building across the street (northeast) in the winter months. [3_zonanalyse.png]","title":"Sun analysis (year basis)"},{"location":"a3.1_Process/#flowchart-solar-envelope","text":"","title":"Flowchart: Solar Envelope"},{"location":"a3.1_Product/","text":"Notebook w2: Solar Envelope","title":"Products"},{"location":"a3.1_Product/#notebook-w2-solar-envelope","text":"","title":"Notebook w2: Solar Envelope"},{"location":"a3_massing/","text":"Massing Here you should include the process and product of your 3rd activity: Massing Title Massing (process): Composition (product) Objective Logically place the functional spaces in between bridges within the building envelope. Procedure Compute a Solar Envelope, i.e. an envelope of cuboids/voxels, some of which are removed because they are in the way of the neighbouring buildings receiving some standard/minimum level of direct sunlight. Fit the circulation manifold into the solar envelope. From the standing platforms corresponding to functional spaces, grow them into voxel clouds within your voxelated envelope. Colour the voxel clouds according to their functionalities.","title":"Massing"},{"location":"a3_massing/#massing","text":"Here you should include the process and product of your 3rd activity: Massing Title Massing (process): Composition (product) Objective Logically place the functional spaces in between bridges within the building envelope. Procedure Compute a Solar Envelope, i.e. an envelope of cuboids/voxels, some of which are removed because they are in the way of the neighbouring buildings receiving some standard/minimum level of direct sunlight. Fit the circulation manifold into the solar envelope. From the standing platforms corresponding to functional spaces, grow them into voxel clouds within your voxelated envelope. Colour the voxel clouds according to their functionalities.","title":"Massing"},{"location":"a4.1_Process/","text":"","title":"Process"},{"location":"a4.1_Product/","text":"","title":"Products"},{"location":"a4_forming/","text":"Forming Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"a4_forming/#forming","text":"Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"about/","text":"About Include your name, the tutors names, and the course name here This web portal has been made for the course BK7083 \u2018\u2019Computational Design Studio\u2019\u2019 given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. The course was guided by Dr. Ir. P. Nourian, Ir. H. Hoogenboom and Ir. S. Azadi. This web portal documents the design process made by group 2, which concludes the following students: Name Student No. Email Role Jiri van den Bos 4801792 j.vandenbos-1@student.tudelft.nl Puzzle Solver Milou Mulder 4833812 m.mulder-7@student.tudelft.nl Journalist Nancy Nguyen 4785029 n.nguyen-2@student.tudelft.nl Reflectionist","title":"About"},{"location":"about/#about","text":"Include your name, the tutors names, and the course name here This web portal has been made for the course BK7083 \u2018\u2019Computational Design Studio\u2019\u2019 given in the minor program Spatial Computing in Architectural Design at the Technical University of Delft. The course was guided by Dr. Ir. P. Nourian, Ir. H. Hoogenboom and Ir. S. Azadi. This web portal documents the design process made by group 2, which concludes the following students: Name Student No. Email Role Jiri van den Bos 4801792 j.vandenbos-1@student.tudelft.nl Puzzle Solver Milou Mulder 4833812 m.mulder-7@student.tudelft.nl Journalist Nancy Nguyen 4785029 n.nguyen-2@student.tudelft.nl Reflectionist","title":"About"},{"location":"documenting/folder_structure/","text":"Folder Structure The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/folder_structure/#folder-structure","text":"The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/guidelines/","text":"Guidelines File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/guidelines/#guidelines","text":"File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/instructions/","text":"Documenting Instructions Installation Install Conda You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda). Create documentation environment Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml Start Work on Documentation After finishing your work on documentation you need to shutdown the server and deactivate the environment. Activate the Environment Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in paranthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template % Run the Local Server Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site. Writing Your Documentation In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations Finish Work on Documentation Server Shut Down To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down... Deactivate Environment After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate Deployment of the Documentation Site Build and Deploy to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository. Setup GitHub Pages For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Instructions"},{"location":"documenting/instructions/#documenting-instructions","text":"","title":"Documenting Instructions"},{"location":"documenting/instructions/#installation","text":"","title":"Installation"},{"location":"documenting/instructions/#install-conda","text":"You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda).","title":"Install Conda"},{"location":"documenting/instructions/#create-documentation-environment","text":"Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml","title":"Create documentation environment"},{"location":"documenting/instructions/#start-work-on-documentation","text":"After finishing your work on documentation you need to shutdown the server and deactivate the environment.","title":"Start Work on Documentation"},{"location":"documenting/instructions/#activate-the-environment","text":"Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in paranthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template %","title":"Activate the Environment"},{"location":"documenting/instructions/#run-the-local-server","text":"Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site.","title":"Run the Local Server"},{"location":"documenting/instructions/#writing-your-documentation","text":"In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations","title":"Writing Your Documentation"},{"location":"documenting/instructions/#finish-work-on-documentation","text":"","title":"Finish Work on Documentation"},{"location":"documenting/instructions/#server-shut-down","text":"To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down...","title":"Server Shut Down"},{"location":"documenting/instructions/#deactivate-environment","text":"After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate","title":"Deactivate Environment"},{"location":"documenting/instructions/#deployment-of-the-documentation-site","text":"","title":"Deployment of the Documentation Site"},{"location":"documenting/instructions/#build-and-deploy","text":"to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository.","title":"Build and Deploy"},{"location":"documenting/instructions/#setup-github-pages","text":"For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Setup GitHub Pages"},{"location":"index/bibliography/","text":"Bibliography Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself.","title":"Bibliography"},{"location":"index/bibliography/#bibliography","text":"Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself.","title":"Bibliography"},{"location":"index/figures/","text":"Figures Here you should include all of your figures and links to the pages that they have been used in. You can embed your only videos like this:","title":"Figures"},{"location":"index/figures/#figures","text":"Here you should include all of your figures and links to the pages that they have been used in. You can embed your only videos like this:","title":"Figures"},{"location":"index/presentations/","text":"Presentations Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"index/presentations/#presentations","text":"Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"index/scripts/","text":"Scripts Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: edges = [] for cell_neigh in cell_neighbors : cell = cell_neigh [ 0 ] for neigh in cell_neigh [ 1 :]: if neigh != - 1 and neigh > cell : edges . append (( cell , neigh ))","title":"Scripts"},{"location":"index/scripts/#scripts","text":"Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: edges = [] for cell_neigh in cell_neighbors : cell = cell_neigh [ 0 ] for neigh in cell_neigh [ 1 :]: if neigh != - 1 and neigh > cell : edges . append (( cell , neigh ))","title":"Scripts"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Generative Relations: MCDA In this workshop, we will learn how enable agents to utilize MCDA (Multi Criteria Decision Analyses) in their spatial behaviors. 0. Initialization 0.1. Load required libraries import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx import pandas as pd np . random . seed ( 0 ) # extra import function def lattice_from_csv ( file_path ): # read metadata meta_df = pd . read_csv ( file_path , nrows = 3 ) shape = np . array ( meta_df [ 'shape' ]) unit = np . array ( meta_df [ 'unit' ]) minbound = np . array ( meta_df [ 'minbound' ]) # read lattice lattice_df = pd . read_csv ( file_path , skiprows = 5 ) # create the buffer buffer = np . array ( lattice_df [ 'value' ]) . reshape ( shape ) # create the lattice l = tg . to_lattice ( buffer , minbound = minbound , unit = unit ) return l 0.2. Define the Neighborhood (Stencil) # creating neighborhood definition stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the center to zero stencil . set_index ([ 0 , 0 , 0 ], 0 ) 0.3. Load the envelope lattice as the avialbility lattice # loading the lattice from csv lattice_path = os . path . relpath ( '../data/voxelized_envelope.csv' ) avail_lattice = lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice ) 0.4. Load Agents Information #dit komt van de andere workshop # loading program (agents information) from CSV prgm_path = os . path . relpath ( '../data/program.csv' ) agn_info = np . genfromtxt ( prgm_path , delimiter = ',' )[ 1 :, 1 :] # extract agent ids agn_ids = agn_info [:, 0 ] # extract agent preferences agn_prefs = agn_info [:, 1 :] <function relpath at 0x00000194B5DF1CA0> 0.5. Initialize environment information layers from Sun Access Lattice and Entrance Access Lattice #the order is important # loading the lattice from csv sun_acc_path = os . path . relpath ( '../data/sun_access.csv' ) sun_acc_lattice = lattice_from_csv ( sun_acc_path ) # loading the lattice from csv ent_acc_path = os . path . relpath ( '../data/ent_access.csv' ) ent_acc_lattice = lattice_from_csv ( ent_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info = [ ent_acc_lattice , sun_acc_lattice ] 1. ABM Simulation 1.1. Initialize the Agents # initialize the occupation lattice occ_lattice = avail_lattice * 0 - 1 # Finding the index of the available voxels in avail_lattice avail_flat = avail_lattice . flatten () avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # count the number of spaces (rows) and intiialize an agent for each space agn_num = len ( agn_info ) # choose the initial location of agents randomly select_id = np . random . choice ( len ( avail_index ), agn_num ) agn_origins = avail_index [ select_id ] # adding the origins to the agents locations agn_locs = [] # for each agent origin ... for a_id , a_origin in zip ( agn_ids , agn_origins ): # add the origin to the list of agent locations agn_locs . append ([ a_origin ]) # set the origin in availablity lattice as 0 (UNavailable) avail_lattice [ tuple ( a_origin )] = 0 # set the origin in occupation lattice as the agent id (a_id) occ_lattice [ tuple ( a_origin )] = int ( a_id ) # this is now based on the id of the agent in the program 1.2. Running the simulation # make a deep copy of occupation lattice cur_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # initialzing the list of frames frames = [ cur_occ_lattice ] # setting the time variable to 0 t = 0 n_frames = 30 # Simulation Loop # main feedback loop of the simulation (for each time step ...) while t < n_frames : # Agent Loop # for each agent ... for a_id in range ( agn_num ): # retrieve the list of the locations of the current agent a_locs = agn_locs [ a_id ] # initialize the list of free neighbours free_neighs = [] # Location loop # for each location of the agent for loc in a_locs : # retrieve the list of neighbours of the agent based on the stencil neighs = avail_lattice . find_neighbours_masked ( stencil , loc = loc ) # for each neighbour ... for n in neighs : # compute 3D index of neighbour neigh_3d_id = np . unravel_index ( n , avail_lattice . shape ) # if the neighbour is available... if avail_lattice [ neigh_3d_id ]: # add the neighbour to the list of free neighbours free_neighs . append ( neigh_3d_id ) # check if found any free neighbour if len ( free_neighs ) > 0 : # convert free neighbours to a numpy array free_neighs = np . array ( free_neighs ) #vanaf hier is er iets aangepast # retrieving the entrance access value of the free neighbours neigh_vals = [] # retrieve agent preferences a_pref = agn_prefs [ a_id ] # Neighbour Evaluation Loop for neigh in free_neighs : neigh_value = 1.0 #het wordt 1, omdat 0 iets zou veranderen als je het multipliceert, 1 niet # for every lattice in the environment informations for i , info_lattice in enumerate ( env_info ): # Here we utilise Fuzzy Logics to be able to compare different layers # of environmental information and evaluate the voxel for the agent. # This method is introduced, and generalised in Pirouz Nourian dissertation: # section 5.7.3, pp. 201-208, eq. 57. You can refer to this section for # comprehensive mathematical details. vox_val = info_lattice [ tuple ( neigh )] agn_vox_val = np . power ( vox_val , a_pref [ i ]) #power-function gives a power to a value (x tot de macht...) neigh_value *= agn_vox_val # add the neighbour value to the list of values neigh_vals . append ( neigh_value ) # convert to numpy array neigh_vals = np . array ( neigh_vals ) # select the neighbour with highest value selected_int = np . argmax ( neigh_vals ) # find 3D intiger index of selected neighbour selected_neigh_3d_id = tuple ( free_neighs [ selected_int ] . T ) # find the location of the newly selected neighbour selected_neigh_loc = np . array ( selected_neigh_3d_id ) . flatten () # add the newly selected neighbour location to agent locations agn_locs [ a_id ] . append ( selected_neigh_loc ) # set the newly selected neighbour as UNavailable (0) in the availability lattice avail_lattice [ selected_neigh_3d_id ] = 0 # set the newly selected neighbour as OCCUPIED by current agent # (-1 means not-occupied so a_id) occ_lattice [ selected_neigh_3d_id ] = a_id # constructing the new lattice new_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # adding the new lattice to the list of frames frames . append ( new_occ_lattice ) # adding one to the time counter t += 1 1.3. Visualizing the simulation p = pv . Plotter ( notebook = True ) base_lattice = frames [ 0 ] # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): f = int ( value ) lattice = frames [ f ] # Add the data values to the cell data grid . cell_arrays [ \"Agents\" ] = lattice . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , agn_num - 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , n_frames ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) var element = $('#284cd1f2-57b6-4e08-bf86-68121b7282fb'); {\"model_id\": \"0b802a6fcbbf46f8bdcd62cf0712f3c6\", \"version_major\": 2, \"version_minor\": 0} [(247.21077512227743, 152.21077512227743, 232.21077512227743), (35.0, -60.0, 20.0), (0.0, 0.0, 1.0)] 2.3. Saving lattice frames in CSV for i , lattice in enumerate ( frames ): csv_path = os . path . relpath ( '../data/abm_mcda/abm_f_' + f ' { i : 03 } ' + '.csv' ) lattice . to_csv ( csv_path ) Credits __author__ = \"Shervin Azadi and Pirouz Nourian\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/spatial_computing_workshops\" __summary__ = \"Spatial Computing Design Studio Workshop on MCDA and Path Finding for Generative Spatial Relations\"","title":"Notebook"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#generative-relations-mcda","text":"In this workshop, we will learn how enable agents to utilize MCDA (Multi Criteria Decision Analyses) in their spatial behaviors.","title":"Generative Relations: MCDA"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#0-initialization","text":"","title":"0. Initialization"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#01-load-required-libraries","text":"import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx import pandas as pd np . random . seed ( 0 ) # extra import function def lattice_from_csv ( file_path ): # read metadata meta_df = pd . read_csv ( file_path , nrows = 3 ) shape = np . array ( meta_df [ 'shape' ]) unit = np . array ( meta_df [ 'unit' ]) minbound = np . array ( meta_df [ 'minbound' ]) # read lattice lattice_df = pd . read_csv ( file_path , skiprows = 5 ) # create the buffer buffer = np . array ( lattice_df [ 'value' ]) . reshape ( shape ) # create the lattice l = tg . to_lattice ( buffer , minbound = minbound , unit = unit ) return l","title":"0.1. Load required libraries"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#02-define-the-neighborhood-stencil","text":"# creating neighborhood definition stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the center to zero stencil . set_index ([ 0 , 0 , 0 ], 0 )","title":"0.2. Define the Neighborhood (Stencil)"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#03-load-the-envelope-lattice-as-the-avialbility-lattice","text":"# loading the lattice from csv lattice_path = os . path . relpath ( '../data/voxelized_envelope.csv' ) avail_lattice = lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice )","title":"0.3. Load the envelope lattice as the avialbility lattice"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#04-load-agents-information","text":"#dit komt van de andere workshop # loading program (agents information) from CSV prgm_path = os . path . relpath ( '../data/program.csv' ) agn_info = np . genfromtxt ( prgm_path , delimiter = ',' )[ 1 :, 1 :] # extract agent ids agn_ids = agn_info [:, 0 ] # extract agent preferences agn_prefs = agn_info [:, 1 :] <function relpath at 0x00000194B5DF1CA0>","title":"0.4. Load Agents Information"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#05-initialize-environment-information-layers-from-sun-access-lattice-and-entrance-access-lattice","text":"#the order is important # loading the lattice from csv sun_acc_path = os . path . relpath ( '../data/sun_access.csv' ) sun_acc_lattice = lattice_from_csv ( sun_acc_path ) # loading the lattice from csv ent_acc_path = os . path . relpath ( '../data/ent_access.csv' ) ent_acc_lattice = lattice_from_csv ( ent_acc_path ) # list the environment information layers (lattices) # the order should match the program matrix env_info = [ ent_acc_lattice , sun_acc_lattice ]","title":"0.5. Initialize environment information layers from Sun Access Lattice and Entrance Access Lattice"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#1-abm-simulation","text":"","title":"1. ABM Simulation"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#11-initialize-the-agents","text":"# initialize the occupation lattice occ_lattice = avail_lattice * 0 - 1 # Finding the index of the available voxels in avail_lattice avail_flat = avail_lattice . flatten () avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # count the number of spaces (rows) and intiialize an agent for each space agn_num = len ( agn_info ) # choose the initial location of agents randomly select_id = np . random . choice ( len ( avail_index ), agn_num ) agn_origins = avail_index [ select_id ] # adding the origins to the agents locations agn_locs = [] # for each agent origin ... for a_id , a_origin in zip ( agn_ids , agn_origins ): # add the origin to the list of agent locations agn_locs . append ([ a_origin ]) # set the origin in availablity lattice as 0 (UNavailable) avail_lattice [ tuple ( a_origin )] = 0 # set the origin in occupation lattice as the agent id (a_id) occ_lattice [ tuple ( a_origin )] = int ( a_id ) # this is now based on the id of the agent in the program","title":"1.1. Initialize the Agents"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#12-running-the-simulation","text":"# make a deep copy of occupation lattice cur_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # initialzing the list of frames frames = [ cur_occ_lattice ] # setting the time variable to 0 t = 0 n_frames = 30 # Simulation Loop # main feedback loop of the simulation (for each time step ...) while t < n_frames : # Agent Loop # for each agent ... for a_id in range ( agn_num ): # retrieve the list of the locations of the current agent a_locs = agn_locs [ a_id ] # initialize the list of free neighbours free_neighs = [] # Location loop # for each location of the agent for loc in a_locs : # retrieve the list of neighbours of the agent based on the stencil neighs = avail_lattice . find_neighbours_masked ( stencil , loc = loc ) # for each neighbour ... for n in neighs : # compute 3D index of neighbour neigh_3d_id = np . unravel_index ( n , avail_lattice . shape ) # if the neighbour is available... if avail_lattice [ neigh_3d_id ]: # add the neighbour to the list of free neighbours free_neighs . append ( neigh_3d_id ) # check if found any free neighbour if len ( free_neighs ) > 0 : # convert free neighbours to a numpy array free_neighs = np . array ( free_neighs ) #vanaf hier is er iets aangepast # retrieving the entrance access value of the free neighbours neigh_vals = [] # retrieve agent preferences a_pref = agn_prefs [ a_id ] # Neighbour Evaluation Loop for neigh in free_neighs : neigh_value = 1.0 #het wordt 1, omdat 0 iets zou veranderen als je het multipliceert, 1 niet # for every lattice in the environment informations for i , info_lattice in enumerate ( env_info ): # Here we utilise Fuzzy Logics to be able to compare different layers # of environmental information and evaluate the voxel for the agent. # This method is introduced, and generalised in Pirouz Nourian dissertation: # section 5.7.3, pp. 201-208, eq. 57. You can refer to this section for # comprehensive mathematical details. vox_val = info_lattice [ tuple ( neigh )] agn_vox_val = np . power ( vox_val , a_pref [ i ]) #power-function gives a power to a value (x tot de macht...) neigh_value *= agn_vox_val # add the neighbour value to the list of values neigh_vals . append ( neigh_value ) # convert to numpy array neigh_vals = np . array ( neigh_vals ) # select the neighbour with highest value selected_int = np . argmax ( neigh_vals ) # find 3D intiger index of selected neighbour selected_neigh_3d_id = tuple ( free_neighs [ selected_int ] . T ) # find the location of the newly selected neighbour selected_neigh_loc = np . array ( selected_neigh_3d_id ) . flatten () # add the newly selected neighbour location to agent locations agn_locs [ a_id ] . append ( selected_neigh_loc ) # set the newly selected neighbour as UNavailable (0) in the availability lattice avail_lattice [ selected_neigh_3d_id ] = 0 # set the newly selected neighbour as OCCUPIED by current agent # (-1 means not-occupied so a_id) occ_lattice [ selected_neigh_3d_id ] = a_id # constructing the new lattice new_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # adding the new lattice to the list of frames frames . append ( new_occ_lattice ) # adding one to the time counter t += 1","title":"1.2. Running the simulation"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#13-visualizing-the-simulation","text":"p = pv . Plotter ( notebook = True ) base_lattice = frames [ 0 ] # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): f = int ( value ) lattice = frames [ f ] # Add the data values to the cell data grid . cell_arrays [ \"Agents\" ] = lattice . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , agn_num - 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , n_frames ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) var element = $('#284cd1f2-57b6-4e08-bf86-68121b7282fb'); {\"model_id\": \"0b802a6fcbbf46f8bdcd62cf0712f3c6\", \"version_major\": 2, \"version_minor\": 0} [(247.21077512227743, 152.21077512227743, 232.21077512227743), (35.0, -60.0, 20.0), (0.0, 0.0, 1.0)]","title":"1.3. Visualizing the simulation"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#23-saving-lattice-frames-in-csv","text":"for i , lattice in enumerate ( frames ): csv_path = os . path . relpath ( '../data/abm_mcda/abm_f_' + f ' { i : 03 } ' + '.csv' ) lattice . to_csv ( csv_path )","title":"2.3. Saving lattice frames in CSV"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_mcda/#credits","text":"__author__ = \"Shervin Azadi and Pirouz Nourian\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/spatial_computing_workshops\" __summary__ = \"Spatial Computing Design Studio Workshop on MCDA and Path Finding for Generative Spatial Relations\"","title":"Credits"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Generative Relations: Path Finidng In this workshop, we will learn about path-finding between agents, and construct distance fields for them. 0. Initialization 0.1. Load required libraries import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx np . random . seed ( 0 ) 0.2. Define the Neighborhood (Stencil) # creating neighborhood definition # stencil beschrijft een neighbourhood stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the center to zero (anders ziet de voxel zichzelf ook als een neighbour) stencil . set_index ([ 0 , 0 , 0 ], 0 ) print ( stencil ) [[[0 0 0] [0 1 0] [0 0 0]] [[0 1 0] [1 0 1] [0 1 0]] [[0 0 0] [0 1 0] [0 0 0]]] 0.3. Load the envelope lattice as the avialbility lattice # loading the lattice from csv lattice_path = os . path . relpath ( '../data/voxelized_envelope.csv' ) avail_lattice = tg . lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice ) 0.4. Load Agents Information # loading program (agents information) from CSV (dit bestand is eigenlijk een tabel) prgm_path = os . path . relpath ( '../data/program.csv' ) agn_info = np . genfromtxt ( prgm_path , delimiter = ',' )[ 1 :, 1 :] #dit laatste zegt dat de eerste row en colomn genegeerd wordt als je dit niet doet krijg je nan (not a number) # extract agent ids #from the table info we will use all the rows and the first colomn agn_ids = agn_info [:, 0 ] # extract agent preferences agn_prefs = agn_info [:, 1 :] print ( agn_ids , ' \\n ' , agn_prefs ) [0. 1. 2.] [[1. 0. ] [0. 1. ] [0.5 0.5]] 1. Distance Field Construction 1.1. Extract the connectivity graph from the lattice based on the defined stencil # find the number of all voxels vox_count = avail_lattice . size # initialize the adjacency matrix (give it a 2D space(matrix with 720 rows/colomns (aantal voxels)) and fill it with 0) adj_mtrx = np . zeros (( vox_count , vox_count )) # Finding the index of the available voxels in avail_lattice (T is to transpose it) avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # fill the adjacency matrix using the list of all neighbours for vox_loc in avail_index : # find the 1D id vox_id = np . ravel_multi_index ( vox_loc , avail_lattice . shape ) # retrieve the list of neighbours of the voxel based on the stencil vox_neighs = avail_lattice . find_neighbours_masked ( stencil , loc = vox_loc ) #print(vox_neighs) # iterating over the neighbours for neigh in vox_neighs : # setting the entry to one adj_mtrx [ vox_id , neigh ] = 1.0 #print(adj_mtrx) # construct the graph g = nx . from_numpy_array ( adj_mtrx ) 1.2. Compute distances on the graph # compute the distance of all voxels to all voxels using floyd warshal algorithm dist_mtrx = nx . floyd_warshall_numpy ( g ) dist_mtrx array([[ 0., inf, inf, ..., inf, inf, inf], [inf, 0., inf, ..., inf, inf, inf], [inf, inf, 0., ..., inf, inf, inf], ..., [inf, inf, inf, ..., 0., 1., 2.], [inf, inf, inf, ..., 1., 0., 1.], [inf, inf, inf, ..., 2., 1., 0.]]) 1.3. Select the entrance voxel p = pv . Plotter ( notebook = True ) # initialize the selection lattice base_lattice = avail_lattice * 0 - 1 # init base flat base_flat = base_lattice . flatten () . astype ( int ) # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): i = int ( value ) # init base flat base_flat = base_lattice . flatten () . astype ( int ) base_flat = base_flat * 0 - 1 base_flat [ i ] = 0 base_new = base_flat . reshape ( base_lattice . shape ) # Add the data values to the cell data grid . cell_arrays [ \"Selection\" ] = base_new . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , len ( base_flat )], title = '1D Index' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) #de voxels worden geteld var element = $('#96271502-a2d0-4908-9d2f-5eba2532f8df'); {\"model_id\": \"e3364b838fc945f29718ffe7c8e24ee5\", \"version_major\": 2, \"version_minor\": 0} [(247.21077512227743, 152.21077512227743, 232.21077512227743), (35.0, -60.0, 20.0), (0.0, 0.0, 1.0)] 1.4. Construct Distance to Entrance Lattice # select the corresponding row in the matrix ent_dist = dist_mtrx [ 682 ] #het getal van de voxel die je kiest voor je ingang #als je een tweede ingang wil, doe dist_mtrx[[682, 51]] (of [[682], [51]] ?? ) #print(ent_dist) #Hiermee kun je zien hoeveel stappen de voxels van jouw voxel vandaan zijn # find the maximum valid value max_valid = np . ma . masked_invalid ( ent_dist ) . max () #print(max_valid) # set the infinities to one more than the maximum valid values ent_dist [ ent_dist == np . inf ] = max_valid + 1 #print(ent_dist) # mapping the values from (0, max) to (1, 0) ent_flat = 1 - ent_dist / ( max_valid + 1 ) # constructing the lattice ent_acc_lattice = tg . to_lattice ( ent_flat . reshape ( avail_lattice . shape ), avail_lattice ) 1.5. Visualize the distance lattice # convert mesh to pv_mesh def tri_to_pv ( tri_mesh ): faces = np . pad ( tri_mesh . faces , (( 0 , 0 ),( 1 , 0 )), 'constant' , constant_values = 3 ) pv_mesh = pv . PolyData ( tri_mesh . vertices , faces ) return pv_mesh # load the mesh from file context_path = os . path . relpath ( '../data/immediate_context.obj' ) context_mesh = tm . load ( context_path ) # initiating the plotter p = pv . Plotter ( notebook = True ) # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions: shape because we want to inject our values grid . dimensions = ent_acc_lattice . shape # The bottom left corner of the data set grid . origin = ent_acc_lattice . minbound # These are the cell sizes along each axis grid . spacing = ent_acc_lattice . unit # Add the data values to the cell data grid . point_arrays [ \"Entrance Access\" ] = ent_acc_lattice . flatten ( order = \"F\" ) # Flatten the Lattice # adding the meshes p . add_mesh ( tri_to_pv ( context_mesh ), opacity = 0.1 , style = 'wireframe' ) # adding the volume opacity = np . array ([ 0.0 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 ]) * 0.6 p . add_volume ( grid , cmap = \"coolwarm\" , clim = [ 0.0 , 1.0 ] , opacity = opacity ) # plotting p . show ( use_ipyvtk = True ) #voxels with a higher value (those which are closer to the entrance) ar red, the rest is getting blue var element = $('#494c30a8-1c34-4a7e-9d71-7c5581fefd07'); {\"model_id\": \"ff4b4eb28dd8415cb35f7cceb4f92159\", \"version_major\": 2, \"version_minor\": 0} [(785.6075686833789, 708.1911636833788, 743.2184808333789), (65.08283250000001, -12.333572500000002, 22.69374465), (0.0, 0.0, 1.0)] 1.6. Save Entrance Access Lattice to CSV # save the sun access latice to csv csv_path = os . path . relpath ( '../data/ent_access.csv' ) ent_acc_lattice . to_csv ( csv_path ) 2. ABM Simulation 2.1. Initialize the Agents #dit is vergelijkbaar met de vorige workshop # initialize the occupation lattice occ_lattice = avail_lattice * 0 - 1 # Finding the index of the available voxels in avail_lattice avail_flat = avail_lattice . flatten () avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # count the number of spaces (rows) and intiialize an agent for each space agn_num = len ( agn_info ) # choose the initial location of agents randomly select_id = np . random . choice ( len ( avail_index ), agn_num ) agn_origins = avail_index [ select_id ] # adding the origins to the agents locations agn_locs = [] # for each agent origin ... for a_id , a_origin in zip ( agn_ids , agn_origins ): # add the origin to the list of agent locations agn_locs . append ([ a_origin ]) # set the origin in availablity lattice as 0 (UNavailable) avail_lattice [ tuple ( a_origin )] = 0 # set the origin in occupation lattice as the agent id (a_id) occ_lattice [ tuple ( a_origin )] = int ( a_id ) # this is now based on the id of the agent in the program 2.2. Running the simulation # make a deep copy of occupation lattice cur_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # initialzing the list of frames frames = [ cur_occ_lattice ] # setting the time variable to 0 t = 0 n_frames = 30 # main feedback loop of the simulation (for each time step ...) while t < n_frames : # for each agent ... for a_id in range ( agn_num ): # retrieve the list of the locations of the current agent a_locs = agn_locs [ a_id ] # initialize the list of free neighbours free_neighs = [] # for each location of the agent for loc in a_locs : # retrieve the list of neighbours of the agent based on the stencil neighs = avail_lattice . find_neighbours_masked ( stencil , loc = loc ) # for each neighbour ... for n in neighs : # compute 3D index of neighbour neigh_3d_id = np . unravel_index ( n , avail_lattice . shape ) # if the neighbour is available... if avail_lattice [ neigh_3d_id ]: # add the neighbour to the list of free neighbours free_neighs . append ( neigh_3d_id ) # check if found any free neighbour if len ( free_neighs ) > 0 : # convert free neighbours to a numpy array free_neighs = np . array ( free_neighs ) # this part is updated # retrieving the entrance access value of the free neighbours neighs_ent_acc = [] for neigh in free_neighs : ent_acc_val = ent_acc_lattice [ tuple ( neigh )] #neigh: [i, j, k] --> is een list dus moet verandert worden naar een tuple --> tuple(neigh): (i, j, k) neighs_ent_acc . append ( ent_acc_val ) # select the neighbour with highest value of entrance access selected_int = np . argmax ( neighs_ent_acc ) # this is updated # find 3D intiger index of selected neighbour selected_neigh_3d_id = tuple ( free_neighs [ selected_int ] . T ) # find the location of the newly selected neighbour selected_neigh_loc = np . array ( selected_neigh_3d_id ) . flatten () # add the newly selected neighbour location to agent locations agn_locs [ a_id ] . append ( selected_neigh_loc ) # set the newly selected neighbour as UNavailable (0) in the availability lattice avail_lattice [ selected_neigh_3d_id ] = 0 # set the newly selected neighbour as OCCUPIED by current agent # (-1 means not-occupied so a_id) occ_lattice [ selected_neigh_3d_id ] = a_id # constructing the new lattice new_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # adding the new lattice to the list of frames frames . append ( new_occ_lattice ) # adding one to the time counter t += 1 2.2. Visualizing the simulation p = pv . Plotter ( notebook = True ) base_lattice = frames [ 0 ] # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): f = int ( value ) lattice = frames [ f ] # Add the data values to the cell data grid . cell_arrays [ \"Agents\" ] = lattice . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , agn_num - 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , n_frames ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) #these voxels are random, but they are moving towards the entrance var element = $('#f9d2241d-f43f-4111-9579-97056e6a9dfc'); {\"model_id\": \"35825558f0974833a4770a75a5ca0b7b\", \"version_major\": 2, \"version_minor\": 0} [(247.21077512227743, 152.21077512227743, 232.21077512227743), (35.0, -60.0, 20.0), (0.0, 0.0, 1.0)] 2.3. Saving lattice frames in CSV for i , lattice in enumerate ( frames ): csv_path = os . path . relpath ( '../data/abm_dist_field/abm_f_' + f ' { i : 03 } ' + '.csv' ) lattice . to_csv ( csv_path ) Credits __author__ = \"Shervin Azadi and Pirouz Nourian\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/spatial_computing_workshops\" __summary__ = \"Spatial Computing Design Studio Workshop on MCDA and Path Finding for Generative Spatial Relations\"","title":"W4 generative relations path finding"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#generative-relations-path-finidng","text":"In this workshop, we will learn about path-finding between agents, and construct distance fields for them.","title":"Generative Relations: Path Finidng"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#0-initialization","text":"","title":"0. Initialization"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#01-load-required-libraries","text":"import os import topogenesis as tg import pyvista as pv import trimesh as tm import numpy as np import networkx as nx np . random . seed ( 0 )","title":"0.1. Load required libraries"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#02-define-the-neighborhood-stencil","text":"# creating neighborhood definition # stencil beschrijft een neighbourhood stencil = tg . create_stencil ( \"von_neumann\" , 1 , 1 ) # setting the center to zero (anders ziet de voxel zichzelf ook als een neighbour) stencil . set_index ([ 0 , 0 , 0 ], 0 ) print ( stencil ) [[[0 0 0] [0 1 0] [0 0 0]] [[0 1 0] [1 0 1] [0 1 0]] [[0 0 0] [0 1 0] [0 0 0]]]","title":"0.2. Define the Neighborhood (Stencil)"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#03-load-the-envelope-lattice-as-the-avialbility-lattice","text":"# loading the lattice from csv lattice_path = os . path . relpath ( '../data/voxelized_envelope.csv' ) avail_lattice = tg . lattice_from_csv ( lattice_path ) init_avail_lattice = tg . to_lattice ( np . copy ( avail_lattice ), avail_lattice )","title":"0.3. Load the envelope lattice as the avialbility lattice"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#04-load-agents-information","text":"# loading program (agents information) from CSV (dit bestand is eigenlijk een tabel) prgm_path = os . path . relpath ( '../data/program.csv' ) agn_info = np . genfromtxt ( prgm_path , delimiter = ',' )[ 1 :, 1 :] #dit laatste zegt dat de eerste row en colomn genegeerd wordt als je dit niet doet krijg je nan (not a number) # extract agent ids #from the table info we will use all the rows and the first colomn agn_ids = agn_info [:, 0 ] # extract agent preferences agn_prefs = agn_info [:, 1 :] print ( agn_ids , ' \\n ' , agn_prefs ) [0. 1. 2.] [[1. 0. ] [0. 1. ] [0.5 0.5]]","title":"0.4. Load Agents Information"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#1-distance-field-construction","text":"","title":"1. Distance Field Construction"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#11-extract-the-connectivity-graph-from-the-lattice-based-on-the-defined-stencil","text":"# find the number of all voxels vox_count = avail_lattice . size # initialize the adjacency matrix (give it a 2D space(matrix with 720 rows/colomns (aantal voxels)) and fill it with 0) adj_mtrx = np . zeros (( vox_count , vox_count )) # Finding the index of the available voxels in avail_lattice (T is to transpose it) avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # fill the adjacency matrix using the list of all neighbours for vox_loc in avail_index : # find the 1D id vox_id = np . ravel_multi_index ( vox_loc , avail_lattice . shape ) # retrieve the list of neighbours of the voxel based on the stencil vox_neighs = avail_lattice . find_neighbours_masked ( stencil , loc = vox_loc ) #print(vox_neighs) # iterating over the neighbours for neigh in vox_neighs : # setting the entry to one adj_mtrx [ vox_id , neigh ] = 1.0 #print(adj_mtrx) # construct the graph g = nx . from_numpy_array ( adj_mtrx )","title":"1.1. Extract the connectivity graph from the lattice based on the defined stencil"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#12-compute-distances-on-the-graph","text":"# compute the distance of all voxels to all voxels using floyd warshal algorithm dist_mtrx = nx . floyd_warshall_numpy ( g ) dist_mtrx array([[ 0., inf, inf, ..., inf, inf, inf], [inf, 0., inf, ..., inf, inf, inf], [inf, inf, 0., ..., inf, inf, inf], ..., [inf, inf, inf, ..., 0., 1., 2.], [inf, inf, inf, ..., 1., 0., 1.], [inf, inf, inf, ..., 2., 1., 0.]])","title":"1.2. Compute distances on the graph"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#13-select-the-entrance-voxel","text":"p = pv . Plotter ( notebook = True ) # initialize the selection lattice base_lattice = avail_lattice * 0 - 1 # init base flat base_flat = base_lattice . flatten () . astype ( int ) # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): i = int ( value ) # init base flat base_flat = base_lattice . flatten () . astype ( int ) base_flat = base_flat * 0 - 1 base_flat [ i ] = 0 base_new = base_flat . reshape ( base_lattice . shape ) # Add the data values to the cell data grid . cell_arrays [ \"Selection\" ] = base_new . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , len ( base_flat )], title = '1D Index' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) #de voxels worden geteld var element = $('#96271502-a2d0-4908-9d2f-5eba2532f8df'); {\"model_id\": \"e3364b838fc945f29718ffe7c8e24ee5\", \"version_major\": 2, \"version_minor\": 0} [(247.21077512227743, 152.21077512227743, 232.21077512227743), (35.0, -60.0, 20.0), (0.0, 0.0, 1.0)]","title":"1.3. Select the entrance voxel"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#14-construct-distance-to-entrance-lattice","text":"# select the corresponding row in the matrix ent_dist = dist_mtrx [ 682 ] #het getal van de voxel die je kiest voor je ingang #als je een tweede ingang wil, doe dist_mtrx[[682, 51]] (of [[682], [51]] ?? ) #print(ent_dist) #Hiermee kun je zien hoeveel stappen de voxels van jouw voxel vandaan zijn # find the maximum valid value max_valid = np . ma . masked_invalid ( ent_dist ) . max () #print(max_valid) # set the infinities to one more than the maximum valid values ent_dist [ ent_dist == np . inf ] = max_valid + 1 #print(ent_dist) # mapping the values from (0, max) to (1, 0) ent_flat = 1 - ent_dist / ( max_valid + 1 ) # constructing the lattice ent_acc_lattice = tg . to_lattice ( ent_flat . reshape ( avail_lattice . shape ), avail_lattice )","title":"1.4. Construct Distance to Entrance Lattice"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#15-visualize-the-distance-lattice","text":"# convert mesh to pv_mesh def tri_to_pv ( tri_mesh ): faces = np . pad ( tri_mesh . faces , (( 0 , 0 ),( 1 , 0 )), 'constant' , constant_values = 3 ) pv_mesh = pv . PolyData ( tri_mesh . vertices , faces ) return pv_mesh # load the mesh from file context_path = os . path . relpath ( '../data/immediate_context.obj' ) context_mesh = tm . load ( context_path ) # initiating the plotter p = pv . Plotter ( notebook = True ) # Create the spatial reference grid = pv . UniformGrid () # Set the grid dimensions: shape because we want to inject our values grid . dimensions = ent_acc_lattice . shape # The bottom left corner of the data set grid . origin = ent_acc_lattice . minbound # These are the cell sizes along each axis grid . spacing = ent_acc_lattice . unit # Add the data values to the cell data grid . point_arrays [ \"Entrance Access\" ] = ent_acc_lattice . flatten ( order = \"F\" ) # Flatten the Lattice # adding the meshes p . add_mesh ( tri_to_pv ( context_mesh ), opacity = 0.1 , style = 'wireframe' ) # adding the volume opacity = np . array ([ 0.0 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 , 0.6 ]) * 0.6 p . add_volume ( grid , cmap = \"coolwarm\" , clim = [ 0.0 , 1.0 ] , opacity = opacity ) # plotting p . show ( use_ipyvtk = True ) #voxels with a higher value (those which are closer to the entrance) ar red, the rest is getting blue var element = $('#494c30a8-1c34-4a7e-9d71-7c5581fefd07'); {\"model_id\": \"ff4b4eb28dd8415cb35f7cceb4f92159\", \"version_major\": 2, \"version_minor\": 0} [(785.6075686833789, 708.1911636833788, 743.2184808333789), (65.08283250000001, -12.333572500000002, 22.69374465), (0.0, 0.0, 1.0)]","title":"1.5. Visualize the distance lattice"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#16-save-entrance-access-lattice-to-csv","text":"# save the sun access latice to csv csv_path = os . path . relpath ( '../data/ent_access.csv' ) ent_acc_lattice . to_csv ( csv_path )","title":"1.6. Save Entrance Access Lattice to CSV"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#2-abm-simulation","text":"","title":"2. ABM Simulation"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#21-initialize-the-agents","text":"#dit is vergelijkbaar met de vorige workshop # initialize the occupation lattice occ_lattice = avail_lattice * 0 - 1 # Finding the index of the available voxels in avail_lattice avail_flat = avail_lattice . flatten () avail_index = np . array ( np . where ( avail_lattice == 1 )) . T # count the number of spaces (rows) and intiialize an agent for each space agn_num = len ( agn_info ) # choose the initial location of agents randomly select_id = np . random . choice ( len ( avail_index ), agn_num ) agn_origins = avail_index [ select_id ] # adding the origins to the agents locations agn_locs = [] # for each agent origin ... for a_id , a_origin in zip ( agn_ids , agn_origins ): # add the origin to the list of agent locations agn_locs . append ([ a_origin ]) # set the origin in availablity lattice as 0 (UNavailable) avail_lattice [ tuple ( a_origin )] = 0 # set the origin in occupation lattice as the agent id (a_id) occ_lattice [ tuple ( a_origin )] = int ( a_id ) # this is now based on the id of the agent in the program","title":"2.1. Initialize the Agents"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#22-running-the-simulation","text":"# make a deep copy of occupation lattice cur_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # initialzing the list of frames frames = [ cur_occ_lattice ] # setting the time variable to 0 t = 0 n_frames = 30 # main feedback loop of the simulation (for each time step ...) while t < n_frames : # for each agent ... for a_id in range ( agn_num ): # retrieve the list of the locations of the current agent a_locs = agn_locs [ a_id ] # initialize the list of free neighbours free_neighs = [] # for each location of the agent for loc in a_locs : # retrieve the list of neighbours of the agent based on the stencil neighs = avail_lattice . find_neighbours_masked ( stencil , loc = loc ) # for each neighbour ... for n in neighs : # compute 3D index of neighbour neigh_3d_id = np . unravel_index ( n , avail_lattice . shape ) # if the neighbour is available... if avail_lattice [ neigh_3d_id ]: # add the neighbour to the list of free neighbours free_neighs . append ( neigh_3d_id ) # check if found any free neighbour if len ( free_neighs ) > 0 : # convert free neighbours to a numpy array free_neighs = np . array ( free_neighs ) # this part is updated # retrieving the entrance access value of the free neighbours neighs_ent_acc = [] for neigh in free_neighs : ent_acc_val = ent_acc_lattice [ tuple ( neigh )] #neigh: [i, j, k] --> is een list dus moet verandert worden naar een tuple --> tuple(neigh): (i, j, k) neighs_ent_acc . append ( ent_acc_val ) # select the neighbour with highest value of entrance access selected_int = np . argmax ( neighs_ent_acc ) # this is updated # find 3D intiger index of selected neighbour selected_neigh_3d_id = tuple ( free_neighs [ selected_int ] . T ) # find the location of the newly selected neighbour selected_neigh_loc = np . array ( selected_neigh_3d_id ) . flatten () # add the newly selected neighbour location to agent locations agn_locs [ a_id ] . append ( selected_neigh_loc ) # set the newly selected neighbour as UNavailable (0) in the availability lattice avail_lattice [ selected_neigh_3d_id ] = 0 # set the newly selected neighbour as OCCUPIED by current agent # (-1 means not-occupied so a_id) occ_lattice [ selected_neigh_3d_id ] = a_id # constructing the new lattice new_occ_lattice = tg . to_lattice ( np . copy ( occ_lattice ), occ_lattice ) # adding the new lattice to the list of frames frames . append ( new_occ_lattice ) # adding one to the time counter t += 1","title":"2.2. Running the simulation"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#22-visualizing-the-simulation","text":"p = pv . Plotter ( notebook = True ) base_lattice = frames [ 0 ] # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): f = int ( value ) lattice = frames [ f ] # Add the data values to the cell data grid . cell_arrays [ \"Agents\" ] = lattice . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , agn_num - 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , n_frames ], title = 'Time' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) #these voxels are random, but they are moving towards the entrance var element = $('#f9d2241d-f43f-4111-9579-97056e6a9dfc'); {\"model_id\": \"35825558f0974833a4770a75a5ca0b7b\", \"version_major\": 2, \"version_minor\": 0} [(247.21077512227743, 152.21077512227743, 232.21077512227743), (35.0, -60.0, 20.0), (0.0, 0.0, 1.0)]","title":"2.2. Visualizing the simulation"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#23-saving-lattice-frames-in-csv","text":"for i , lattice in enumerate ( frames ): csv_path = os . path . relpath ( '../data/abm_dist_field/abm_f_' + f ' { i : 03 } ' + '.csv' ) lattice . to_csv ( csv_path )","title":"2.3. Saving lattice frames in CSV"},{"location":"notebooks/w4_generative_relations/notebooks/w4_generative_relations_path_finding/#credits","text":"__author__ = \"Shervin Azadi and Pirouz Nourian\" __license__ = \"MIT\" __version__ = \"1.0\" __url__ = \"https://github.com/shervinazadi/spatial_computing_workshops\" __summary__ = \"Spatial Computing Design Studio Workshop on MCDA and Path Finding for Generative Spatial Relations\"","title":"Credits"}]}