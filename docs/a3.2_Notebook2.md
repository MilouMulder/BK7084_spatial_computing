----
**Task List**

- [X] Text
- [ ] image info
- [X] Flowchart
- [X] Charts
- [ ] Growing video
- [ ] voxel cloud
- [X] Pseudo code
- [ ] Notebook
------

In the following script, the voxelized envelope, as created in [Notebook 1](/a2.2_Notebook1/) will be optimized in regards to its shadow footprint or solar envelope. In the first part of this script, the logic is set up to use ladybug and trimesh to shoot rays both from the different sun positions towards the voxels and inverse from voxels towards sun positions. 
Firstly, a Solar access calculation is done with vectors from suns towards the voxels. If these rays intersect with the context mesh they are set to 0. 
Secondly and more importantly, a solar envelope calculation is done by shooting rays from the voxels towards the sun. Then this list of rays is compared with the list from solar access. Rays that meet the conditions visualized in this next image are saved.

> Insert image

When the solar analysis is done we the list of voxels is split using a low and high bound threshold value. A threefold of lattices are established in this step: Voxels to recalculate, voxels to keep and voxels to remove.
The resolution of these lattices is increased to the desired size. In our case, one voxel is split into 8 smaller voxels. This is called an Octree system. This whole process can be seen as Pass 1. With the recalculation lattice, the process is repeated, until in our case the voxel size was 3.6. A total of three passes. 
Each pass is individually exported as CSV or pickled into a txt file.


##Flowchart: Solar Envelope
>add text

<figure>
  <img src="..\img\flowcharts\02_solar_envelope.jpg" alt="Flowchart - Solar envelope" style="width:90%; height:90%;">
  <figcaption>Figure X: Flowchart - Solar envelope</figcaption>
</figure>

>keep updating this flowchart! And make a link to a bigger version of this image.

## additional diagrams
###Sun analysis (year basis)
&nbsp;&nbsp;&nbsp;&nbsp;Before running the Solar Envelope we researched how the surrounding buildings cast a shadow on the current site throughout the year. Here for the analysis ran every 15th day of the month at 12:00 oâ€™clock. This research shows us that if we would not increase the height of the building, it will only cast a shadow on the lower part of the building across the street (northeast) in the winter months.

<figure>
  <img src="..\img\3\3_zonanalyse.png" alt="Pre-sun-analysis" style="width:80%; height:80%;">
  <figcaption>Figure X: Pre-sun-analysis</figcaption>
</figure>

## Pseudo code 
>add text with link to notebook

```Python
#Import envelope mesh and context mesh
envelope_mesh = envelope.stl
context_mesh = extended_context_reduced.stl

#Visualize meshes with pyvista

#Import lattice
On first pass lattice = lattice_14_4.csv
On subsequent passes lattice = lattice_continue.csv

#Visualize lattice with pyvista

#Define Sunpath
Choose day_multiple carefully, between 15 and 75
Compute the sun_vectors to shoot
Visualize suns with pyvista

#Compute intersections
Create two seperate lists for ray direction for envelope and access
Check the number of rays carefully, should definetly be under 120k and ideally under 100k

Compute the intersections for solar_acces
Compute the intersections for solar_envelope

#Aggregate Simulation results
Translate list of rays with 1 or 0 on hit or miss to a value per voxel.
For solar envelope check if shadow is not cast by context by comparing the acces and envelope lists

#Save solar information to an array
Iterate over each voxel and add its solar acces and envelope value

#Visualize solar acces and envelope with pyvista

#Save solar data to a csv
write solar access to 'solar_acces_(current voxel size).csv'
write solar envelope to 'solar_envelope_(current voxel size).csv'

#Initialize Variables
voxel sizes:
    current
    required 
    final
Treshold values:
    low bound
    high bound
Shape:
    current lattice height
    current lattice length
    current lattice width

#Initialize Envelope CSV
import: current size solar Envelope
    read shape via lattice
    read data with csv.reader
CSV useable:
    Convert strings to int where possible
    Remove empty lists
    Arrange in Lattice shape

#Use Tresholds to split data
For each voxel
    if the envelope value is between the Tresholds
        Scale voxel to the required size and add to recalculate coords

    elif the envelope value is between 0 and high bound
        Scale voxel to the required size and add to keep coords

    elif the envelope value is greater than the high bound
        Scale voxels to the required size and add to remove coords

#Find the min and max of keep coords per x,y coordinate
For each x y in keep coords
    if voxel is in keep coords
        add z to temp_list
    find min and max in temp_list add with x y to min_max_list ([x,y,min_z,max_z])

#Establish seperate lists for x y and min max
For each list in min_max_list
    add x y to min_max_coords
    add min max to min_max_values

#Fill any voxel between the max and min
For each list in min_max_list
    For each z value between min and max
        add coordinates to calculate_coords

#Use a list of all voxels under the high bound to find which to keep
establish full_coords as combination of recalculate coords and keep coords

for each voxel in full_coords
    if x y is in min_max_values
        find the index of x y in min_max_values
        use index to find min max
        
        if z is greater than the min value
            add this index to a pop_list

establish final_coords as full_coords with both pop_list and remove coords removed

Scale the final_coords voxels to the final size


#Use the largest size voxel csv as basis for translation
Import the CSV
    read data with csv.reader
CSV useable:
    Convert strings to int where possible
    Remove empty lists
    Place top lines into top_csv
    Place rest of the lines into rest_csv

#Translate the current solar data to the final resolution
using np.kron upscale the solar acces and envelope
pickle solar envelope to 'solar_envelope_pass_(num).txt'
pickle solar access to 'solar_access_pass_(num).txt'

#Use final_coords to create a list of final size voxels to print after this pass
For each top_csv lines
    set both the shape and size correct

Scale the rest_csv voxels into the final size
Set each boolean to false

For each voxel in final_coords
    if the voxel is also in rest_csv
        set the boolean to True

Establish final_result as the combination of top_csv and rest_csv

#Repeat this process for the voxels in calculate_coords
For each top_csv lines
    set both the shape and size correct

Scale the rest_csv voxels into the final size
Set each boolean to false

For each voxel in final_coords
    if the voxel is also in rest_csv
        set the boolean to True

Establish calculate_result as the combination of top_csv and rest_csv

Write final_result to 'lattice_print_pass_(num).txt' with proper enters
Write calculate_result to 'lattice_continue.txt' with proper enters
```   



## Visualisations of the result
> add text

### Growing video
>add text

>add video

### Voxelcloud
>add text

>add image
